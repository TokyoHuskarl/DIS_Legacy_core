def eventid = 91

def Const_cos10 = 984  //0.9848077


__fn macro_parabolic_projectile_cal_angle $v $l {
	/*TT1 = $l //pix
	TT1 = pow($l,2)
	TT1 *= g_perFPS // avoid overflow (pix*1000)/f
	TT2= $v / 10//pix*1000/10f
	TT1 = divmul(TT1,pow(TT2,2),5000) //
	//TT2 = muldiv($l,10000,TT1) // (*10000)
	TT2 = muldiv($l,100000,TT1) // (*100)
	//TT3 = 1
	TT4 = divmul(TT2,4,TT2)
	TT4 -= 100
	TT5 = sqrt(TT4,1)//root *10^4 ->?*10^*/
	//TT2 *= 1000//set digit the same
	//TT1 = $l //pix
	TT1 = muldiv($l, $l, 1000) //(pix*10)
	TT1 *= 20//g_perFPS/100 // (pix*10000)
	TT2= $v //pix*1000/10f
	TT2 = muldiv($l,1000,divmul(TT1,pow(TT2,2),20)) //(pix*1000)/(pix*1000)*1000
	//TT3 = 1
	TT4 = TT2/1000 //prepare for sqrt
	TT4 = muldiv(TT4,TT4,4)
	TT4 -= 1
	TT5 = sqrt(TT4,10000)//root *10^4 ->?*10
	@if TT4 > 0 {
		//return 
		TT6 = TT2 / -2 * 10 //* 100// -2 /// / -2 --digit*100
		TT7 = TT6 + TT5
		TT8 = TT6 - TT5

		TT6 =  360000000 + v[348]
		//TT6 = TT5 - TT2 
		reg1 = atan2(TT6,360000000,1000) // poc pock cpok
		reg2 = 1
	}.else bl{
		//cannot reach the goal with given parameters!
		reg2 = -1
	}
	func_devlog("cal proc: v1:\v[341] v2:\v[342]  v4:\v[344] v5:\v[345] v6 chosen:\v[346], (\v[347],\v[348])")



}

cev .id(eventid), .name("effect:arrow"), {
__if DIS_EXPERIMENTAL == 1 {
	@if s[141] .isOn() {
	    @loop v[1017] .dst v[320] {
		macro_effect_array_increment_ptr()
		@if v[effect_set_ptr] <= 1 {
		    // clean up 
		    zeroArray100.copy v[effect_set_ptr], EffectArraySize
		    zeroArray100.copy effect_EffectType, EffectArraySize


		    // set effect type
		    effect_EffectType = EffectType_Has_LinkedFunc
		    // set event id
		    effect_CallEffFunc = eventid
		    // "描画終了時イベント番号設定"
		    effect_LinkedFunc = cevid_func_erace_effect
		    // set parents and targets - these vars handed down from ranged_shoot function
		    effect_ParentObject = v[609]
		    effect_TargetObject = v[623]
		    effect_DirWhenShot = v[637]
		    
		    effect_Timer = 400 //Arrows can exist only for 400 frames... just in case if the gravity won't work well
		    //Set base Positions... 
		    effect_RelativeX = v[607]
		    effect_RelativeY = v[608]
		    effect_RelativeX.copy effect_SavedPositionX,2
		    effect_RelativeX.copy effect_milX,2
		    v[__id(effect_milX)..__id(effect_milY)] *= 1000
		    TT1 = rnd(-4,4)
		    effect_TargetObjectX = v[624] + TT1
		    TT1 = rnd(-4,4)
		    effect_TargetObjectY = v[625] + TT1
		    //Cal Distance
		    effect_TargetObjectX.copy TT1, 2
		    TT1.sub effect_RelativeX, 2
		    TT1.copy effect_milPixVx,2
		    TT1.mul TT1, 2
		    effect_Distance_to_goal = TT1 + TT2
		    effect_Distance_to_goal = sqrt(effect_distance_to_goal,1000)
		    //Set XY velo
		    effect_milPixVab = agent_AAvelocity
		    TT1 = atan2(effect_milPixVy,effect_milPixVx,1000)
		    effect_milPixVx = muldiv(effect_milPixVab,cos(TT1,1000,1000),1000)
		    effect_milPixVy = muldiv(effect_milPixVab,sin(TT1,1000,1000),1000)
		    func_devlog("XY 2d vector: v0:\v[4014] vx:\v[4012] vy:\v[4013] angle:\v[341]")

		    //Then start caluclation
		    macro_parabolic_projectile_cal_angle(effect_milPixVab effect_Distance_to_goal)
		    effect_Distance_to_goal /=1000
		    effect_Angle = -reg1
		    effect_milVz = muldiv(effect_milPixVab,-sin(effect_Angle,1000,1000),1000)
		    func_devlog("cal return: Distance: \v[4020]pix Angle: \v[21]mildegree vz:\v[4042]")

		    effect_EffectType.copy v[v[301]], EffectArraySize

		    // "ポインタセット開始"
		    // "画像"
		    v[310] = v[242] + v[1220]
		    @pic[v[310]].show {
			"arrows\arrow"
			.pos v[361], v[362] .center
			.scrollWithMap
			.chromakey 1
			.scale 100
			.trans 100
			.rgbs 100, 100, 100, 100
			.mapLayer 7
			.eraseWhenTransfer
			.affectedByTint
			.affectedByFlash
			.affectedByShake
		    }
		    // "発射音"
		    // "仕上げに登録消す"
		    v[242..243] += 1
		    @if `s[v[609] + 500] {
			@if v[182] < 2 {
			    v[182] += 1
			    // "#########################"
			    v[471] = 11550
			    v[472] = divmul(40, 100, v[2216])
			    v[473] = rnd(90, 100)
			    v[474] = divmul(v[361] + v[1001], v[1281], 50)
			    // "#########################"
			    @cmd v[471], "bow_shoot_01", .args v[472], 3
			    
			}
			v[13] = v[v[295]]
			v[330] = v[301] + 17
			v[334] = v[301] + 23
			v[v[330]].copy v[14], 2
			v[v[334]].copy v[16], 2
			v[18] = v[242]
			// "###################"
			// "v1=amount"
			// "v2=direction -1=right 0=cent 1=left"
			// "v3=timer"
			// "v4=parent"
			@loop v[1017] .dst v[320] {
			    v[244] %= v[1199]
			    v[351] = v[244] * 50 + v[1198]
			    @if v[v[351]] <= 1 {
				// "まず清掃"
				v[1301].copy v[v[351]], 50
				// "ポインタセット開始"
				// "設定"
				v[v[351]] = 2
				// "Timer"
				v[v[351] + 49] = v[13]
				// "Set itself"
				v[v[351] + 3] = 120
				// "Set Amount"
				v[v[351] + 1] = v[11]
				// "Set Dire"
				v[v[351] + 27] = v[12]
				// "Set Pare"
				v[v[351] + 9] = v[18]
				// "XY set"
				v[357] = v[351] + 6
				v[361].copy v[v[357]], 2
				// "Access14 = x"
				v[345] = v[351] + 4
				v[361].copy v[v[345]], 2
				v[v[345]..v[345] + 1] *= 10000
				// ""
				v[345] = v[351] + 17
				v[14].copy v[v[345]], 2
				v[345] = v[351] + 23
				v[16].copy v[v[345]], 2
				// "v"
				v[345] = v[351] + 11
				v[16].copy v[v[345]], 2
				v[v[345]] .sub v[14], 2
				v[v[345]].copy v[314], 2
				v[v[345]] = muldiv(v[v[345]], 10000, v[13])
				v[345] += 1
				v[v[345]] = muldiv(v[v[345]], 10000, v[13])
				// "Angle"
				v[345] = atan2(v[315], v[314], 1000)
				v[345] += v[345] <= 0 ? 360000 : 0
				v[v[351] + 27] = v[345]
				// "仕上げに登録消す"
				v[244] += 1
				@break
				
			    }
			    v[244] += 1
			    
			}
			
			
		    }
		    @break
		    
		}
		v[242] += 1
		
	    }
	    
	    s[141].off
	    
	} .else bl {

	    v[v[301]].copy effect_EffectType, EffectArraySize

	    effect_RelativeX.copy effect_SavedPositionX,2

	    effect_milX.add effect_milPixVx,2
  	    v[53].copy TT1, 2
	    v[341..342] *= 1000
	    effect_milX.add TT1,2


	    effect_milX.copy effect_RelativeX,2
	    v[__id(effect_RelativeX)..__id(effect_RelativeY)] /= 1000
	    effect_milVz -= g_perFPS 
	    effect_milZ += effect_milVz
	    effect_RelativeY -= effect_milZ/1024

	    effect_RelativeX.copy TT1,2
	    TT1.sub effect_SavedPositionX,2
	    effect_Angle = atan2(v[342], v[341], 1000) +360000

	    
	    @if effect_Timer > 0 {
		    @if effect_milZ <= 0 {
		    	effect_Timer=0
		    }
	    }
	    effect_EffectType.copy v[v[301]], EffectArraySize
		// "Draw"
		v[310] = v[241] + v[1220]
		@pic[v[310]].show {
		    "arrows\arrow"
		    .pos effect_RelativeX, effect_RelativeY .center
		    .scrollWithMap
		    .chromakey 1
		    .scale 100
		    .trans 0
		    .rgbs 100, 100, 100, 100
		    .angle effect_Angle, 1000
		    .mapLayer 7
		    .eraseWhenTransfer
		    .affectedByTint
		    .affectedByFlash
		    .affectedByShake
		}
		// "タイマー切れのときの処理"
		@if effect_Timer == 0 {
		    v[422] = 1
		    v[362] += 11
		    effect_RelativeX.copy v[11], 2
		    @call .cev 2010
		    // "WATER"
		    @if `v[v[4505] + v[23]] & 1 {
			@pic[v[310]].erase
			// "Bubble Particle"
			@loop v[1017] .dst v[320] {
			    v[244] %= v[1199]
			    v[351] = v[244] * 50 + v[1198]
			    @if v[v[351]] <= 1 {
				// "init"
				v[1301].copy v[v[351]], 50
				v[v[351]] = 1
				// "timer"
				v[v[351] + 49] = 3
				// "Set itself"
				v[v[351] + 3] = 133
				// "set pos"
				v[341] = v[351] + 6
				v[607].copy v[v[341]], 2
				v[244] += 1
				@break
				
			    }
			    v[244] += 1
			    
			}
			
			
		    } .else bl {
			v[314] = effect_Angle//v[v[339]] - v[341]
			v[314] = atan2(v[315] + 8, v[314], 1000)
			v[314] += v[314] <= 0 ? 360000 : 0
			@pic[v[310]].show {
			    "arrows\arrow_g"
			    .pos effect_RelativeX, effect_RelativeY .center
			    .scrollWithMap
			    .chromakey 1
			    .scale 100
			    .trans 0
			    .rgbs 70, 70, 70, 70
			    .angle v[314], 1000
			    .mapLayer 3
			    .eraseWhenTransfer
			    .affectedByTint
			    .affectedByFlash
			    .affectedByShake
			}
			//__if DEBUG_BUILD ==0{v[v[301]]=1}
			v[v[301] + 10] = 89
			
		    }
		    
		}
		   
	}


}.elif DIS_EXPERIMENTAL == 0{

/* "https://dixq.net/g/s_01.html
Ox = 330
Oy = 331
DirX = 332
DirY = 333
TargX = 334
TargY = 335
FrameCounter1 = 336
FrameCounter**2 = 337
NeedFrame =338
X = 339
Y = 340
PreX = 341
PreY = 342"*/



	@if s[141] .isOn() {
	    @loop v[1017] .dst v[320] {
		v[242] %= v[1017]
		v[301] = v[242] * 100 + v[1018]
		@if v[v[301]] <= 1 {
		    // "まず清掃"
		    v[1301].copy v[v[301]], 100
		    // "ポインタセット開始"
		    v[300] = v[301] + 3
		    v[296] = v[301] + 10
		    v[295] = v[301] + 99
		    v[330] = v[301] + 17
		    v[331] = v[301] + 18
		    v[334] = v[301] + 23
		    v[335] = v[301] + 24
		    v[332] = v[301] + 20
		    v[333] = v[301] + 21
		    v[336] = v[301] + 9
		    v[338] = v[301] + 2
		    v[339] = v[301] + 6
		    v[340] = v[301] + 7
		    v[341] = v[301] + 8
		    v[342] = v[301] + 22
		    // "イベント番号設定"
		    v[v[300]] = 91
		    // "描画終了時イベント番号設定"
		    v[v[296]] = 31
		    // "親Obj・子Obj"
		    v[v[341]] = v[609]
		    v[v[342]] = v[623]
		    v[v[301] + 36] = v[637]
		    // "#代入"
		    v[v[301]] = 2
		    v[v[295]] = v[700]
		    v[v[338]] = v[603]
		    v[v[330]] = v[607]
		    v[v[331]] = v[608]
		    v[v[334]] = v[624]
		    v[v[335]] = v[625]
		    v[v[334]] += rnd(-3, 3)
		    v[v[335]] += rnd(-3, 3)
		    v[v[332]] = v[v[330]] + v[v[334]]
		    v[v[333]] = v[v[331]] + v[v[335]]
		    v[v[332]] /= 2
		    v[v[333]] /= 2
		    v[v[333]] -= rnd(48, 64)
		    v[v[339]] = v[v[330]]
		    v[v[340]] = v[v[331]]
		    // "#Arrow Swoosh Time"
		    v[v[301] + 50] = v[700] / 2
		    // "画像"
		    v[310] = v[242] + v[1220]
		    @pic[v[310]].show {
			"arrows\arrow"
			.pos v[361], v[362] .center
			.scrollWithMap
			.chromakey 1
			.scale 100
			.trans 100
			.rgbs 100, 100, 100, 100
			.mapLayer 7
			.eraseWhenTransfer
			.affectedByTint
			.affectedByFlash
			.affectedByShake
		    }
		    // "発射音"
		    // "仕上げに登録消す"
		    v[242..243] += 1
		    @if `s[v[609] + 500] {
			@if v[182] < 2 {
			    v[182] += 1
			    // "#########################"
			    v[471] = 11550
			    v[472] = divmul(40, 100, v[2216])
			    v[473] = rnd(90, 100)
			    v[474] = divmul(v[361] + v[1001], v[1281], 50)
			    // "#########################"
			    @cmd v[471], "bow_shoot_01", .args v[472], 3
			    
			}
			v[13] = v[v[295]]
			v[330] = v[301] + 17
			v[334] = v[301] + 23
			v[v[330]].copy v[14], 2
			v[v[334]].copy v[16], 2
			v[18] = v[242]
			// "###################"
			// "v1=amount"
			// "v2=direction -1=right 0=cent 1=left"
			// "v3=timer"
			// "v4=parent"
			@loop v[1017] .dst v[320] {
			    v[244] %= v[1199]
			    v[351] = v[244] * 50 + v[1198]
			    @if v[v[351]] <= 1 {
				// "まず清掃"
				v[1301].copy v[v[351]], 50
				// "ポインタセット開始"
				// "設定"
				v[v[351]] = 2
				// "Timer"
				v[v[351] + 49] = v[13]
				// "Set itself"
				v[v[351] + 3] = 120
				// "Set Amount"
				v[v[351] + 1] = v[11]
				// "Set Dire"
				v[v[351] + 27] = v[12]
				// "Set Pare"
				v[v[351] + 9] = v[18]
				// "XY set"
				v[357] = v[351] + 6
				v[361].copy v[v[357]], 2
				// "Access14 = x"
				v[345] = v[351] + 4
				v[361].copy v[v[345]], 2
				v[v[345]..v[345] + 1] *= 10000
				// ""
				v[345] = v[351] + 17
				v[14].copy v[v[345]], 2
				v[345] = v[351] + 23
				v[16].copy v[v[345]], 2
				// "v"
				v[345] = v[351] + 11
				v[16].copy v[v[345]], 2
				v[v[345]] .sub v[14], 2
				v[v[345]].copy v[314], 2
				v[v[345]] = muldiv(v[v[345]], 10000, v[13])
				v[345] += 1
				v[v[345]] = muldiv(v[v[345]], 10000, v[13])
				// "Angle"
				v[345] = atan2(v[315], v[314], 1000)
				v[345] += v[345] <= 0 ? 360000 : 0
				v[v[351] + 27] = v[345]
				// "仕上げに登録消す"
				v[244] += 1
				@break
				
			    }
			    v[244] += 1
			    
			}
			
			
		    }
		    @break
		    
		}
		v[242] += 1
		
	    }
	    
	    s[141].off
	    
	} .else bl {
	    v[330] = v[301] + 17
	    v[331] = v[301] + 18
	    v[334] = v[301] + 23
	    v[335] = v[301] + 24
	    v[332] = v[301] + 20
	    v[333] = v[301] + 21
	    v[336] = v[301] + 9
	    v[339] = v[301] + 6
	    v[340] = v[301] + 7
	    v[300] = v[301] + 3
	    v[338] = v[301] + 2
	    v[v[330]] .add v[53], 2
	    v[v[332]] .add v[53], 2
	    v[v[334]] .add v[53], 2
	    v[295] = v[301] + 99
	    // "#処理開始"
	    @if v[v[338]] < v[v[300]] {
		// "微分より直前の座標をもとめたほうがはやいね"
		v[v[339]].copy v[341], 2
		v[337] = pow(v[v[336]], 2)
		// "321~323 = ([Frame] - t)"
		v[320] = v[v[338]] - v[v[336]]
		// "X"
		// "#まず第1項から"
		v[321] = pow(v[320], 2)
		v[321] *= v[v[330]]
		// "#まず第2項から"
		v[322] = v[320] * 2
		v[322] *= v[v[332]] * v[v[336]]
		// "#まず第3項から"
		v[323] = v[337] * v[v[334]]
		// "DrawX"
		v[v[339]] = (v[321]+v[322] + v[323]) / pow(v[v[338]], 2)
		v[361] = v[v[339]]
		// "Y"
		// "#まず第1項から"
		v[321] = pow(v[320], 2) * v[v[331]]
		// "#第2項"
		v[322] = v[320] * 2 * v[v[333]] * v[v[336]]
		// "#第3項"
		v[323] = v[337] * v[v[335]]
		// "DrawX"
		v[v[340]] = v[321]
		v[v[340]] += v[322] + v[323]
		v[v[340]] /= pow(v[v[338]], 2)
		v[362] = v[v[340]]
		// "進行角度だす"
		v[314] = v[v[339]] - v[341]
		// "V Save"
		v[v[301] + 11] = v[314]
		// ""
		v[315] = v[v[340]] - v[342]
		v[314] = atan2(v[315], v[314], 1000) + (v[314] <= 0 ? 360000 : 0)
		// "Angle Save"
		v[v[301] + 27] = v[314]
		// "Draw"
		v[310] = v[241] + v[1220]
		@pic[v[310]].show {
		    "arrows\arrow"
		    .pos v[361], v[362] .center
		    .scrollWithMap
		    .chromakey 1
		    .scale 100
		    .trans 0
		    .rgbs 100, 100, 100, 100
		    .angle v[314], 1000
		    .mapLayer 7
		    .eraseWhenTransfer
		    .affectedByTint
		    .affectedByFlash
		    .affectedByShake
		}
		v[v[336]] += 1
		// "タイマー切れのときの処理"
		@if v[v[295]] == 0 {
		    v[422] = 1
		    v[362] += 11
		    v[361].copy v[11], 2
		    @call .cev 2010
		    // "WATER"
		    @if `v[v[4505] + v[23]] & 1 {
			@pic[v[310]].erase
			// "Bubble Particle"
			@loop v[1017] .dst v[320] {
			    v[244] %= v[1199]
			    v[351] = v[244] * 50 + v[1198]
			    @if v[v[351]] <= 1 {
				// "init"
				v[1301].copy v[v[351]], 50
				v[v[351]] = 1
				// "timer"
				v[v[351] + 49] = 3
				// "Set itself"
				v[v[351] + 3] = 133
				// "set pos"
				v[341] = v[351] + 6
				v[607].copy v[v[341]], 2
				v[244] += 1
				@break
				
			    }
			    v[244] += 1
			    
			}
			
			
		    } .else bl {
			v[314] = v[v[339]] - v[341]
			v[314] = atan2(v[315] + 8, v[314], 1000)
			v[314] += v[314] <= 0 ? 360000 : 0
			@pic[v[310]].show {
			    "arrows\arrow_g"
			    .pos v[361], v[362] .center
			    .scrollWithMap
			    .chromakey 1
			    .scale 100
			    .trans 0
			    .rgbs 70, 70, 70, 70
			    .angle v[314], 1000
			    .mapLayer 3
			    .eraseWhenTransfer
			    .affectedByTint
			    .affectedByFlash
			    .affectedByShake
			}
			//__if DEBUG_BUILD ==0{v[v[301]]=1}
			v[v[301] + 10] = 89
			
		    }
		    
		}
		
	    }
	    
	}
}

}
