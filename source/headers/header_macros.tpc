// misc macro
// included in header_common.tpc

//cev 2000
//$regX and $regY must be vars set at address in a row
__fn macro_convert_relativeXY_into_maptileXY $TileX $TileY $regX $regY {
	v[__id($TileX)].copy $regX, 2
	v[__id($regX)] += 8
	v[__id($regY)] += 24
	v[__id($regX)].sub LEGV_MainMAP_PointOfRefereneX, 2 //?f0
	v[__id($regX)] /= 16
	v[__id($regY)] /= 16
}

//cev 2001
__fn macro_convert_maptileXY_into_relativeXY $TileX $TileY $regX $regY {
	@map[v[501]].setVehiclePos .airship .pos $TileX, $TileY .retain
	v[__id($regX)] = airship.scrx
	v[__id($regY)] = airship.scry
	v[__id($regY)] -= 8
}


__fn macro_convert_absolute_coord $RelXstart $regXstart {
	// ?
	//v[__id($RelXstart)].copy $regXstart, 2
	//v[__id($regXstart)].sub LEGV_MainMAP_PointOfRefereneX, 2 //?f0
	
}


// return the result to reg1, if reg1 = 1, thenthe given cord is out of map
__fn macro_ck_if_given_rel_coord_is_inside_map $X $Y { 
	macro_convert_relativeXY_into_maptileXY($X,$Y,reg2,reg3)
	reg1 = between(reg2,Map_LimitCoordX_min,Map_LimitCoordX_max)&&between(reg3,Map_LimitCoordY_min,Map_LimitCoordY_max)?0:1

}


// convert t[] to v[]
__fn t2v $t $v {
	t[__id($t)].toNum $v
}

