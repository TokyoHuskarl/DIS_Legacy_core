#toClip

//パッケージ・ライブラリ・コマンド関数の定義はheader_scalescriptに記述
#include "./header_scalescript.tpc"

//libsampleとadditional_libはSSLib_sampleに別個定義されている
#include "./SSLib_sample.tpc"

//DISコンソール用ライブラリとパッケージも持ってくる
#include "./../Toolbox/header_rmsh_scalescript.tpc"

/*

	SScmd_Mode_Construct_Link = 1 //Create Link string 
	SScmd_Mode_Exec = 2 //simply execute function in interpreter process 
	SScmd_Mode_Call = 3 //execute function from raw string command - slower than Mode_Exec
	SScmd_Mode_Convert = 4 //when you convert script for interpreter
	SScmd_Mode_Help = 5 //help helper
*/

//パッケージの定義
__fn SScmdPackage_TEST $LINKstr $md $counter $given_v_or_str $flags {
		//内側でコンストラクタを呼ぶ（パッケージを作りたい場合コンストラクタの配置は手動…）
		//名前，データベースを作る文字列変数，モード，パッケージ内をスコープとするツクール用一時変数（処理ごとにデータは失われる），文字列または変数（モードによって変動），[ライブラリリスト]
		SScmdPackage_Build ("SamplePackage",$LINKstr, $md, $counter, $given_v_or_str, $flags, {

		//メタ関数として定義されたライブラリ関数を（ちゃんとライブラリコンストラクタを使って作られているのであれば）単にコピペするだけでパッケージに当該ライブラリ内のコマンドを読み込める
		libtest($LINKstr $md $counter $given_v_or_str $flags)

		//then feel free to add your libs like this
		libsample($LINKstr $md $counter $given_v_or_str $flags)

		//just put lib fucntions with these same arguments given from SScmdPackage. 
		//By doing that, those libs will be automatically added into your cmd package.
		//well that's only if your libs were made correctly with SScmdLibBuild(...), though.
		additional_lib($LINKstr $md $counter $given_v_or_str $flags)
		})
}

//コンストラクタSScmdLib_Build()を使ってrmmsgコマンドを大量に含むtestlibを宣言
__fn libtest $LINKstr $md $i $given_v_or_str $flags {
	SScmdLib_Build("testlib" $LINKstr, $md, $i, $given_v_or_str,$flags, [
		{SScommand($LINKstr, $md, $i, void,"rmmsg",nargs_nolimit,[str],[{@msg.show SSargs0},{@msg.show "help helper"}])},
		{SScommand($LINKstr, $md, $i, void,"rmmsg",nargs_nolimit,[str],[{@msg.show SSargs0},{@msg.show "help helper"}])},
		{SScommand($LINKstr, $md, $i, void,"rmmsg",nargs_nolimit,[str],[{@msg.show SSargs0},{@msg.show "help helper"}])},
		{SScommand($LINKstr, $md, $i, void,"rmmsg",nargs_nolimit,[str],[{@msg.show SSargs0},{@msg.show "help helper"}])},
		{SScommand($LINKstr, $md, $i, void,"rmmsg",nargs_nolimit,[str],[{@msg.show SSargs0},{@msg.show "help helper"}])}, 	
		{SScommand($LINKstr, $md, $i, void,"rmmsg",nargs_nolimit,[str],[{@msg.show SSargs0},{@msg.show "help helper"}])},
		{SScommand($LINKstr, $md, $i, void,"rmmsg",nargs_nolimit,[str],[{@msg.show SSargs0},{@msg.show "help helper"}])}, 	
		{SScommand($LINKstr, $md, $i, void,"rmmsg",nargs_nolimit,[str],[{@msg.show SSargs0},{@msg.show "help helper"}])},
		{SScommand($LINKstr, $md, $i, void,"rmmsg",nargs_nolimit,[str],[{@msg.show SSargs0},{@msg.show "help helper"}])}, 	
		{SScommand($LINKstr, $md, $i, void,"rmmsg",nargs_nolimit,[str],[{@msg.show SSargs0},{@msg.show "help helper"}])},
	])
}
//コマンドは複雑になってもわかりやすく書く記法でも定義できる->./SSLib_sample.tpc


defv var2 = 12
def PROJECT_NAME = "test"

@if v[114514]==4545 {
	@comment "コマンドデータベースコンストラクト機能呼び出し->args[0]に渡されているt[1]にコマンドデータベース展開"
	SScmdPackage_TEST(t[1],SScmd_Mode_Construct_Link,v[1],v[10],0)
}

@if v[114514]==4545 {
	@comment "処理機能呼び出し->数値データにコンパイル済みのスクリプトを渡す(コンパイル部分未完成)"
	SScmdPackage_TEST(t[1],SScmd_Mode_Exec,v[1],v[10],0)
}

@if v[114514]==4545 {
	@comment "source/Toolbox/header_rmsh_scalescript.tpcからロードしたDISコンソール機能用パッケージ"
	@comment "処理機能呼び出し->渡されたコマンドをデータベースから捜してIDを取得してifループにかけて実行（１コマンド分しか実装されていない）"

	//パッケージ関数処理中に__id($)処理を行っているため変数番号文字列変数を直で扱うことはできない
	//ので適当な文字列変数にコピー
	t[2998].asg t[v[523]]
	//SHELL_CMD_PACKはToolbox側のヘッダで宣言されている文字列変数
	//コンソール呼び出し時にSSmcd_Mode_Construct_Linkでデータベースが展開される
	//Scale ScriptはDIS本体/Toolboxとは独立しているためテストでは定義が必要
	deft SHELL_CMD_PACK = 1
	ShellCommandPackage(SHELL_CMD_PACK,SScmd_Mode_Call,SScmdDynCounter,t[2998],SScmd_Flag_Cmdline)
}

//FROM "./../Toolbox/header_rmsh_scalescript.tpc"
//ShellCommandPackage(SHELL_CMD_PACK,SScmd_Mode_Construct_Link,var1,var2,SScmd_Flag_Cmdline)
//ShellCommandPackage(SHELL_CMD_PACK,SScmd_Mode_Call,var1,t[341],SScmd_Flag_Cmdline)
//libtest(t[1],SScmd_Mode_Construct_Link,v[1],v[10],SScmd_Flag_Init_Link)
