//#############################
//Scale script tokens

//SS process uses picture as a temporary buffer so you must give one picID to SS
def SS_buffer_picID = 100

//
defv SScmdDynCounter = 508
vname[__id(SScmdDynCounter)],"SScmdDynCounter" 




defv {

	SSvar1 = 11
	SSvar2
	SSvar3
	SSvar4
	SSvar5
	SSvar6
	SSvar7
	SSvar8
	SSvar9

	SSreg1 = 21
	SSreg2 = 22

	SSnargs = 29
	SScmdnum = 30
}



def nargs_max = 16
deft {
	SScmdStrList = 790
	str_SS_partsave = 508


	str_SSreg1 = 502
	str_SSreg2
	str_SSreg3



	SScmd = 2999
	SSargs0
	SSargs1
	SSargs2
	SSargs3
	SSargs4
	SSargs5
	SSargs6
	SSargs7
	SSargs8

	parsSScmd = __id(SScmd) + nargs_max
	parsSSargs0
	parsSSargs1
	parsSSargs2
	parsSSargs3
	parsSSargs4
	parsSSargs5
	parsSSargs6
	parsSSargs7
	parsSSargs8

}

//String buffer
def SSstrBuffer_size = 16 // maybe you don't need so many str buffers
defs {
	SSstrBuffer0 = __id(parsSScmd) + nargs_max //starts from here
}

defv ROOT_INDEX = 739348
defv Var_NEST_DEPTH = 510
defv NEST_COUNTER = 509
defs BREAK_SWITCH = 291
def NEST_HEADER_LENGTHS =12

defv Var_save_offset =282

defv DEBUG_NESTCOUNT=4750

def Const_NEST_VAR_ADDRESS_BEGIN = 739348
def ROOT_INDEX_ADDRESS = Const_NEST_VAR_ADDRESS_BEGIN



	def SS_LF ="
"


def regstr = t[__id($regstr)]
def targstr = t[__id($targstr)]
def setvar = v[__id($setvar)]
def getvar = v[__id($getvar)]
def targvar = v[__id($targvar)]
def targaddress = $targadd 
def getaddress = $getadd
def setaddress = $getadd




//#############################


//SS buffer setting

def {
	//ATTENTION!
	// If you just want to use SS just as a developement support tool, 
	//IT'S HIGHLY RECOMMENDED NOT TO CHANGE THESE CONSTS.

	//Also, the most important const (SS_buffer_picID) that decides which picture ID SS uses as a buffer is not here.


	SS_buffer_array_amount = 30 //You can expand if you need to store some datas in SSbuffer

	SS_buffer_array_Size = 256 //array size shouldn't be changed if you don't understand what comments below saying. 


	SS_buffer_array_address_index = 0 // SS will basically use the first n byte of each array[n][0] as an index for the array.
	SS_buffer_index_mask = SS_buffer_array_Size - 1 //in the first setting, mask is set as 0xFF 
	// Thus if you change array size for some purpose, you should consider about those hex matters.

	// I don't think the further expantion of the array size of SS would be necessary in a regular RM2003 project.
	//Yes, I do expect people may try changing the buffer array size to 4096 or more bigger number, 
	//but I don't assure SS's proper work. 
	//Don't blame me even if something bad happens after you change array size - Tokyo Huskarl

	// After all, as a result, we will have 
	//SSarray[SS_buffer_array_amount][SS_buffer_array_Size] as a picture in RM2003 when you use Scale Script.



	SS_buffer_address_global = 0 //ss use buffer[0][0] as global array for ss process

		SS_buffer_global_adress_str_buffer_index = 1 //SS use buffer[0][1] as index counter for strings that picture buffer cannot contain  
		SS_buffer_global_adress_func_loop = 2 //SS use buffer[0][2] as function loop counter 


	SS_buffer_address_func_process = 3 //use when you try changing 


	//FIX_SS_BUFFER = 1 //if you change this to 0, you can use 
}






__fn SS_LET_TPC_READ $do {$do}

def Scale_Script_Shebang = "#!SCALE_SCRIPT"

def EOF = "EOF"
def NEST_START = "[N:"
def NEST_START_SIZE = 3
def NEST_INNER_HEAD="*nH"
def NEST_FOOTER = "*nE"
def NEST_FOOTER_SIZE_sub1 = 2

//variable types
//void
def void = 0

//number
def var = 1
//RM var adress
def refvar = 2
//string
def str = 3
//RM string adress
def refstr = 4
//true or false
def bool = 5
//RM switch adress
def refbool = 6 
//picture data
def pic = 7
//picture ID
def refpic = 8

__if __defined(TRUE){}.else bl{def TRUE = 1}
__if __defined(FALSE){}.else bl{def FALSE = 0}


//SScmd Modes!
def {

	SScmd_Mode_Construct_Link = 1 //Create Link string 
	SScmd_Mode_Exec = 2 //simply execute function in interpreter process 
	SScmd_Mode_Call = 3 //execute function from raw string command - slower than Mode_Exec
	SScmd_Mode_Convert = 4 //when you convert script for interpreter
	SScmd_Mode_Help = 5 //help helper
}

//find (), then-> search cmdList -> get 



//SScmd_Flag
def {
	SScmd_Flag_Init_Link = 0x1 
	SScmd_Flag_Cmdline = 0x2
}

#include "./header_scalescript_macros.tpc"
#include "./header_scalescript_str_funcs.tpc"

//################################
//FUNCTION DECLARATIONS BEGIN 
//################################


SS_funcgroup("SSBuffer functions", {

	/*def bufferfunc_init = {
		__if FIX_SS_BUFFER == 1 { $badd = SS_buffer_picID } // if you change FIX_SS_BUFFER you can flexiblly set in your project
	}*/



	//just init and generate picture for buffer
	// init_SSb might be better name for this function
	__fn construct_SSb {
		/*
		@pic.getInfo[SS_buffer_picID]{
			.currentRect(a, b, c, d)
		}*/

		@pic[SS_buffer_picID].erase

		@pic.strpic[SS_buffer_picID]{
			""
			.pos(-1000000, -1000000) //not in your screen
			.center
			.useChromakey
			.scale(100)
			.trans(100)
			.rgbs(100, 100, 100, 100)
			.size(SS_buffer_array_Size, SS_buffer_array_amount)
			.font("", 12)
			.skin("")    
			.noframe    
			.noGradation
			.noShadow 
			.noPadding
			.nobg
		}
	}
	
	__fn pop_element_from_SSb_array $targvar $arrayid {
		get_SSb_array_index(SSreg1,$arrayid)
		get_SSb_array_element($targvar,$arrayid,SSreg1)
		set_SSb_array_element(0,$arrayid,SSreg1)
		SSreg1 -= 1
		set_SSb_array_index(SSreg1,$arrayid)

	}

	__fn push_element_to_SSb_array $targvar $arrayid {
		get_SSb_array_index(SSreg1,$arrayid)
		SSreg1 += 1
		set_SSb_array_element($targvar,$arrayid,SSreg1)

	}


	//fundamental functions

	//set RM vars starts from startvar to field of an array 
	__fn set_SSb_array $startvar $arrayid $elm_add $index $amount {
		set_picture_line(__id($startvar), SS_buffer_picID, $index, $arrayid, $amount)
	}

	//set setvar to array index
	__fn set_SSb_array_index $setvar $arrayid {
		set_picture_pixel(__id($setvar), SS_buffer_picID, SS_buffer_array_address_index, $arrayid)
	}

	//set setvar to an element adress of an array 
	__fn set_SSb_array_element $setvar $arrayid $elm_add {
		set_picture_pixel(__id($setvar), SS_buffer_picID, $elm_add, $arrayid)
	}

	//extract picked array elements to continuous RM vars starts from $startvar.
	__fn extract_SSb_array $startvar $arrayid $index $amount {
		get_picture_horizontal_line(__id($startvar), SS_buffer_picID, $index, $arrayid, $amount)
	}

	__fn extract_SSb_array_all $startvar $arrayid {
		get_picture_horizontal_line(__id($startvar), SS_buffer_picID, SS_buffer_array_address_index, $arrayid, SS_buffer_array_Size)
	}

	//get array index to getvar
	__fn get_SSb_array_index $getvar $arrayid {
		get_SSb_array_element(__id(getvar), SS_buffer_picID, SS_buffer_array_address_index, $arrayid)
	}

	//get array element
	__fn get_SSb_array_element $getvar $arrayid $elm_add {
		get_picture_pixel(__id(getvar), SS_buffer_picID,$elm_add, $arrayid)
	}


})



//################################
//SScmdObjects structure 
//################################

//To learn how to build script command Library or Command Package, check SSLib_sample.tpc 

__fn SScmdPackage_Build $pkName $LINKstr $md $counter $given_v_or_str $flags $block {

	__if __id(SScmdnum) == __id($counter) {
		ERROR_SScmdPackage_DO_NOT_USE_SScmdnum_as_Package_counter
	}

	v[__id($counter)] = 0

	
	__if $md == SScmd_Mode_Construct_Link {
		SScomments_for_RMEditer(__str("t[" __id($LINKstr) "] will be initialized to construct Link for SS Command Package named[" $pkName "]"))
		//init link
		v[__id($given_v_or_str)]=0
		t[__id($LINKstr)].asg ""
		v[__id($counter)] = 0


	}.elif $md == SScmd_Mode_Exec {
		macro_demiliterset
		SScmdPackage_ExecMode_parsing(t[__id($given_v_or_str)])
		SScmd.toNum(SScmdnum)


	}.elif $md == SScmd_Mode_Call {
		macro_demiliterset
		//SScmdPackage_ExecMode_parsing(t[__id($given_v_or_str)])
		t[__id($given_v_or_str)] .split($delimiter, SScmd, SSnargs)//nargs?
		SSLink_search_cmd(parsSScmd,SScmd,$LINKstr,0)
		@if parsSScmd.neq "NULL"{
			parsSScmd.split(",", parsSScmd, SSvar2)
			parsSScmd.toNum(SScmdnum)
		}.else bl{//NULL
			SScmdnum = -1
		}

	}

	@if SScmdnum != -1 {
		@loop 1 {
			$block
		}
		__if $md == SScmd_Mode_Construct_Link {
			str_SSreg1.asg v[__id($given_v_or_str)]
			t[__id($LINKstr)].asg .cat(__str("<" $pkName ":" ), str_SSreg1, t[__id($LINKstr)]) // set package name in the first line
		}
	}.else bl{ //Failed


	}


}

//Check RAW script

__fn SScmdPackage_ExecMode_parsing $LINKstr $md $given_command_string $delimiter {

	//Temporary this expects only call mode 

	//args type check won't be done here, just check syntax error

	//t[__id($given_v_or_str)] .split($delimiter, SScmd, SSnargs)//nargs?
	def SScmdPk_ExeMd_CmdStr = t[__id($given_command_string)]

	deft SScmdPk_ExeMd_Save = __id(str_SS_partsave)



	defv SScmdPk_ExeMd_Index = __id(SSvar1)
	defv SScmdPk_ExeMd_PosChar = __id(SSvar2)
	defv SScmdPk_ExeMd_Temp = __id(SSvar3)

	//get the end point of the command
	//SScmdPk_ExeMd_CmdStr.exinStr("$", SScmdPk_ExeMd_EOC,)

	//test 
	$ckStr = SScmdPk_ExeMd_CmdStr

	$index = SScmdPk_ExeMd_Index
	$charpos = SScmdPk_ExeMd_PosChar
	$temp = SScmdPk_ExeMd_Temp

	defv parse_pointer = __id(SSvar4)
	$expected_nargv = SSvar5
	


	def macro_parse_checkloop_goto_next_try = {
		t[parse_pointer].asg str_SS_partsave
		SSnargs += 1 //++
		parse_pointer += 1
		$index = $charpos
	}

	def macro_copy_from_got_range_in_loop_strSave = {
		SScmdPk_ExeMd_Temp = SScmdPk_ExeMd_PosChar - 1 
		SScmdPk_ExeMd_Save.asg .subs($ckStr, $index, $temp)
	}



	SScmdPk_ExeMd_Index = 0
	SSnargs = -1
	

	//init pointer
	parse_pointer = __id(SScmd) 

/*
	@loop bl {
		SScmdPk_ExeMd_CmdStr.inStr($delimiter, SScmdPk_ExeMd_PosChar,.beg(SScmdPk_ExeMd_Index))
		@if SScmdPk_ExeMd_PosChar < 0{ //found delimiter!
			@if SScmdPk_ExeMd_Index == 0{ //if this is the first delimiter
				//This must be a Command... so
				macro_copy_from_got_range_in_loop_strSave

				//check it and save its Cmdid assigned in the pack to SScmd
				SSLink_search_cmd(SScmd,str_SS_partsave,$LINKstr,0)

				@if SSreg1 != -1{ //yes it's commandpars
					$func_amount += 1
					SScmd.split($delimiter, parsSScmd, $expected_nargv) //throw prototype to parsSScmd 
					macro_parse_checkloop_goto_next_try

				}.else bl{ //damn it, the command is undefined!
					@break
				}

			}.else bl{ //another demiliter found! 
				//set pointer to check?

				//copy to see what is in side...
				macro_copy_from_got_range_in_loop_strSave

				//get first char
				str_get_char(str_SSreg2,str_SS_partsave,0)
				
				//Start checking what the char is
				@if str_SSreg2.eq """" { //this looks like string!

					//insert check fundtion to check if str is expected in that args
					
					//Try to get the end of given string
					$temp = $charpos + 1
					SScmdPk_ExeMd_CmdStr.inStr("""", $temp, .beg($temp))
					@if $temp == -1{ // illegal string found. - need final "

						@break
					}.elif $temp > $charpos { // the demiliter that found the last process seems just something inside string block.
						//so try hard to reach actual demiliter...
						$charpos = $temp
						@loop bl {
							SScmdPk_ExeMd_CmdStr.inStr($delimiter, $charpos, .beg($charpos))
							@if $charpos == -1 { //This string seems the last args.. 
								@break 2 //so break all loop inside this function
							}.elif $temp <= $charpos { // finally out of the string.
								//so we will go to the next loop to check next argv!
								macro_parse_checkloop_goto_next_try
								@breaka // break this loop.
							}
						}
					}.else bl { //the string doesn't contain delimiter within it
						macro_parse_checkloop_goto_next_try
					}


				}.elif str_SSreg2.eq "$"{ //at least not string. check if It's Global var.



				}.else bl{ //not global nor string.


					//ACHTUNG! VARIABLE can be put here... but after completion of var design in scale script
					

					//Check if there's function
					str_SS_partsave.inStr("(", $temp, .beg($index) ) //check if this argv has ( - token of function

					@if $temp == -1 { //no function seemingly
						//then this must be number or whatever. why worry 
						macro_parse_checkloop_goto_next_try

					}.else  bl{ 
						// oh shit, it's going to be hassle.
						$charpos += 1
						//$temp is ( position
						//use SSvar8 as char number
                                                SSvar8 = $temp - $charpos
						SSvar8 -= 1SS
						
						//Check the function id
						str_SS_partsave.asg .subs($ckStr, $index, SSvar8)
						SSLink_search_cmd(SScmd,str_SS_partsave,$LINKstr,0)
						@if SSreg1 != -1{ //yes it's commandpars
							//then replace func string with @FUNCID
							SScmd.split($delimiter, parsSScmd, $expected_nargv) //throw prototype to parsSScmd

							//save backup to buffer 

							SScmd.asg .cat("@",parsSScmd,"")
							SScmdPk_ExeMd_CmdStr.asg .ins(SScmdPk_ExeMd_CmdStr, str_SS_partsave, SScmd)
							macro_parse_checkloop_goto_next_try
							//and just go next..

						}.else bl{ //damn it, the command is undefined!
							@break
						}



					}
				}



			}
			
		}.else bl{ //no more demiliter found, finish the loop 
			@break
		}

	}

	
	//afterthat...
	//$func_amount = SSvar6 
	
	SScmdPk_ExeMd_CmdStr.split("@", SSstrBuffer0, SSvar6)

	SSvar8 = SSvar6 + __id(SSstrBuffer0)
	t[SSvar8].split(")", parsSScmd, SSvar7)
	SSvar7 += __id(parsSScmd)
	SSvar8 = __id(SSstrBuffer0)
	@loop SSvar6 {

	}
	


	//ACHTUNG - 
	//MAYBE THIS PART SHOULD BE PARTED FROM the LOOP, Count up functions and disintegrate them into string buffers 
	//then process in string buffers in turn

	//Command will just get what is already digested by the Package in any circumstance..
	//Well it will be like... 
	//count up ( and ), check folded and how many funcs inside >> n  
	//then pick up most nested function, then replace it with some link, push the function to string buffer[n]
	//then n-- and do the same thing until n == 0

	//after that, convert into SS obj code ->set into each argv :D
	//msg(argv,func(1,fung(241))
	//@CMD:nargv,2,3(@CMD,1,Z2@CMD,241Z2,;
	//"@"in static string temporary replace with "\@" in obj code 
	//{fn}@:

	//FN{Funcs amount within Cmd}
	//FN2@echo:1,1!@return_combine!3,114514,2!@nothing!0,"fugg:D"
	//!{n}!@ -> split ! -> remove n! (@~) last demiliter -> push to buffer -> in buffer... set 
	//retarded 




	
*/
}

__fn SScmdLib_Build $LibName $LINKstr $md $i $given_v_or_str $flags $cmdList { //str,str,SScmd_Mode,var,var,SScmd_Flag,[SScommand]

	SScomments_for_RMEditer(__str("Link String t[" __id($LINKstr) "] loads Command Library:[" $LibName "]"))

	//$i = SScommand list size counter var


	//Link Construct Mode
	__if $md == SScmd_Mode_Construct_Link {//SS command library construction mode - in this Mode $given_v_or_str work as just temp var to count down and save command amount 
		__loop $cmdList $block {//just let them create link
			v[__id($i)] += 1
			$block
			v[__id($given_v_or_str)]+=1
		}

		//Save amount of commands registered to the link str
		//in the first line of the link str
		str_SSreg1.asg v[__id($given_v_or_str)]
		t[__id($LINKstr)].asg .cat(str_SSreg1, ">", t[__id($LINKstr)]) // use < as a header token - temporary 





	//Execute Mode
	}.elif $md == SScmd_Mode_Exec {//$given_v_or_str work as converted str id:argv[0],argv[1]...


		//can this really faster than the old DIS script?
		__loop $cmdList $block {
			v[__id($i)] += 1
			@if SSvar1 == v[__id($i)] {
				$block
				@break
			}
		}



	//Script convert mode
	//cmdname(var arg0,v:mapev1...etc) -> cmdname=cmdid,arg0,arg1
	}.elif $md == SScmd_Mode_Convert {
		__loop $cmdList $block {
			v[__id($i)] += 1
			//Get command ID type name argc and so on
			$block
		}



	//Execute Mode
	}.elif $md == SScmd_Mode_Call {//$given_v_or_str work as converted str id:argv[0],argv[1]...

		//can this really faster than the old DIS script?
		__loop $cmdList $block {
			v[__id($i)] += 1
			@if SScmdnum == v[__id($i)] {
				$block
				@break
			}
		}

	}

}

SS_funcgroup("SScommand functions",{
	//Command type function 
	def nargs_nolimit = -1

	//SS command !
	__fn SScommand $LINKstr $mode $ID $type $NAME $nargv $argv_type_list $funclist {

		SScomments_for_RMEditer(__str("COMMAND - " $NAME ":"))
		
		//Construct Link
		__if $mode == SScmd_Mode_Construct_Link {
			t[__id($LINKstr)].cat $NAME
			t[__id($LINKstr)].cat "="
			t[__id($LINKstr)].cat $ID
			t[__id($LINKstr)].cat ","
			__loop $argv_type_list $el {
				t[__id($LINKstr)].cat $el
				t[__id($LINKstr)].cat ","
			}
			t[__id($LINKstr)].cat ";"
			//end


		//Execute Mode / Help Mode
		}.elif $mode == SScmd_Mode_Exec {//Just execute functions from list
			SScmdfunc($funclist, $mode)


		//Script Convert Mode
		}.elif $mode == SScmd_Mode_Convert{
			//Return ID type name argc and alle
			SSreg1 = $type
			str_SSreg1.asg $NAME
			SScmd.asg $ID
			__loop $argv_type_list $elm $i {
				$ptr = __id(SSargs0) + $i
				t[$ptr].asg $elm	
			}
			
		}.elif $mode == SScmd_Mode_Call{
			//Str
			SScmdfunc($funclist, $mode)


		}
	}


	__fn SScmdfunc $functionlist $callwhat {

		__loop $functionlist $block $i {
			__if $i == 0 {
				__if $callwhat != SScmd_Mode_Help { $block }

			}.elif $i == 1 {
				__if $callwhat == SScmd_Mode_Help { $block }
			}
		
		}

	}

	//return $string to reg1 
	__fn SSreturn_string $string {
		str_SSreg1.asg $string
	}

	__fn SSreturn $type $var {

	}





	//This will be called whenever a function's args contains another function 
	__fn save_current_cmd_to_SSb_array $arrayid $args_index_which_called_this {

		//get current index data to SSvar1 from selected array
		get_SSb_array_index(SSvar1,$arrayid)
		SSvar1 &= SS_buffer_index_mask

		SSvar2 = SSvar1+1

		//Convert all 
		@loop SSnargs .dst(Ssvar3){
			SSvar3 += __id(SScmd)

		}


		set_SSb_array $startvar $arrayid $elm_add $index $amount
		

	}



	
	__fn SScommand_convert_args_into_argv $args_start $amount {
		__loop $amount $i {
			$n = $i + __id(SSvar2)
			$m = __id($args_start) + $i
			t[$m].toNum v[$n]
		}
	}

	__fn SScomments_for_RMEditer $comment {
		__if __defined(DEBUG_BUILD) {
			__if DEBUG_BUILD == 1{ // to optimise your game, you can set build infomation
				@comment __str("ScaleScript:" $comment)
			}
		}.else bl{
			@comment __str("ScaleScript:" $comment)
		}
	}

})



__fn proc_SS_args_var $str $mode {
	//$ global
	//v: local
	//v[n] RMvar
	//b[n][m] picture buffer 
	//p[id][n][m] 
	str_get_char(str_SSreg1,$str,0)

	//Check first char
	@if str_SSreg1.eq "$" {
		//GLOBAL

	}.else bl{
		//NOT GLOBAL
		//Then get index[1]
		str_get_char(str_SSreg2,$str,1)
		@if str_SSreg2.eq ":"{
			//Looks like local var

		}.elif str_SSreg2.eq "["{
			//Looks like RM var or picture


		}.else bl{
			//Loos like just a Number,
		}
	}


}

__fn proc_SS_argv_str $str $mode{}


def macro_demiliterset = {
	__if $flags & SScmd_Flag_Cmdline {
		$delimiter = " "
	}.else bl{
		$delimiter = ","
	}
}




__fn GIVE_METAVAR2BLOCK $block $var1 $var2 $var3 $var4 $var5 $var6 $var7 $var8 $var9 $var10 { //is these $vars even needed? idk 
	$block
}


//dummy
__fn MAIN $do {$do}
__fn SETcmd $do {$do}
__fn HELP $do {$do}

//meaningless dummy just to make source look more clear
__fn SS_funcgroup $funcgroupname $do {$do}



