

defv PF_ID_holder = 4594

__fn refresh_deployed_agent_data {
	v[Pathfinding_AgentData_head_ptr].copy Head_of_Agent_Buffer_PF, 64
}

__fn func_pathfinding_Astar() {
	// deploy to 
	refresh_deployed_agent_data()

	__if DEBUG_BUILD == 1 {
	    @pic[1..800].erase
	    
	}

	// "#移動先壁チェック"
	//TT2 = Pathfinding_AgentData_head_ptr + 21
	//v[TT2].copy Temp3, 2

	pfagent_MoveUvectorX.copy Temp3, 2
	@if Temp4 < -30 {
	    // "Up"
	    @if Temp3 > 30 {
		// "Right"
		v[4586] = 3
		
	    } .else bl {
		@if Temp3 < -30 {
		    // "Left"
		    v[4586] = 1
		    
		} .else bl {
		    v[4586] = 2
		    
		}
		
	    }
	    
	} .else bl {
	    @if Temp4 > 30 {
		// "Down"
		@if Temp3 > 30 {
		    // "Right"
		    v[4586] = 5
		    
		} .else bl {
		    @if Temp3 < -30 {
			// "Left"
			v[4586] = 7
			
		    } .else bl {
			v[4586] = 6
			
		    }
		    
		}
		
	    } .else bl {
		@if Temp3 > 30 {
		    // "Right"
		    v[4586] = 4
		    
		} .else bl {
		    @if Temp3 < -30 {
			// "Left"
			v[4586] = 8
			
		    }
		    
		}
		
	    }
	    
	}

	// "Goal Node setting start"
	 pfagent_TargetAgentID = pfagent_AgentBits & AgentBits_FLAG_ForcemoveFlag ? 0 : pfagent_TargetAgentID

	//The Agent has any Target agent?
	@if  pfagent_TargetAgentID > 0 { //Yes, it does

	    //Then get Target Agent position into var1 var2
	    TT2 =  pfagent_TargetAgentID * 300 
	    TT2 += 4726
	    v[TT2].copy Temp11, 2 // FIXED!
	    
	} .else bl { // No, it doesn't

	    // Then get Target Agent position into var1 var2
	    //Temp17 = TT2 + 14
	    //TT2 = Pathfinding_AgentData_head_ptr + 41
	    //Temp17 = max(v[Temp17], 0)
	    //TT2 += Temp17 * 2
	    //v[TT2].copy var1, 2

	    TT2 =__id(pfagent_HoldPointX) // Pathfinding_AgentData_head_ptr + 41
	    Temp17 = max(pfagent_LeftWPtoChase, 0)
	    TT2 += Temp17 * 2
	    v[TT2].copy var1, 2

	    // convert into tile coordinate - maybe you can deal with this without this func if the PF agent has the target agent
	    @call .cev 2000
	    reg1.copy Temp11, 2

	    
	}

	// The goal node is set, now to run actual node check process
	// "safety in order not to set out of map as a goal node"
	@if `between(reg2, v[70], v[72]) {
	    @if `between(reg1, v[69], v[71]) {

		//Temp11 = (Temp11 - v[69]) // / 2
		//v[312] = (v[312] - v[70]) // / 2
		Temp11.sub v[69],2
		v[311..312] /= 2

		//opt 27.4.23
		//var2 = Temp11 + v[312] * v[433] + 1
		var2 = Temp11 + 1
		var2 += v[312] * v[433]

		// "Start Node"
		//TT2 = Pathfinding_AgentData_head_ptr + 26
		//v[TT2].copy Temp11, 2
		pfagent_MapX.copy Temp11, 2
		Temp11.sub v[69],2
		v[311..312] /= 2

		// var1 = start node id
		var1 = Temp11 + 1 
		var1 += v[312] * v[433]
		/* "#v1=start	v2=goal"*/
		// "#""INIT"
		v[4593] = Bool_PF_Wall_Detection == 1 ? 2 : 6
		v[4592] = v[4593] + 1
		v[4595] = 0

		v[ptr_null].copy v[4582],4
		var1.copy PF_start_Node, 2
		
		//ACHTUNG - need to change into .copy proc
		v[v[4568]..v[4600] + 40000] = 0

		// check from start node
		PF_current_checking_Node = PF_start_Node
		var10 = PF_start_Node

		// "######add start Node to openlist"
		v[v[4568] + v[4582]] = var10
		v[4582] += 1

		v[v[4568]].sortDescending v[4582]
		v[4588] = (PF_goal_Node - 1) * v[4564] + v[4569]
		v[v[4588]].copy v[4588], 2
		v[341] = v[204] >= 380 ? 512 : 1024
		v[378] = -1

		@loop v[341] .dst v[2064] {

		    v[2075] = v[2064] + 1
		    v[4581] = (PF_current_checking_Node - 1) * v[4564] + v[4569] + 11
		    //ACHTUNG - need to change into .copy proc
		    v[3601..3608] = 999999999

		    //ACHTUNG - need to change into .copy proc   
		    v[ptr_null].copy v[3609],8 //v[3609..3617] = 0
		    v[4591] = 0

		    // "Euclid"

		    // These parts using MapIndex variables that were initially set in the Classic version.
		    // So it can be unexpected roots of bugs (all classic features must be eventually removed, otherwise it will annoy you later)
		    @if v[2064] == 0 {
			// "First attempt"
			@loop 8 .dst v[2065] {
			    @if v[v[4581]] > 0 {
				//opt 28.4.23
				//save the v[v[4581]] / 10 to TT11
				TT11 = v[v[4581]] / 10

				@if TT11  == PF_goal_Node {
				    v[v[4600] + TT11 - 1] = PF_current_checking_Node
				    PF_current_checking_Node = TT11 
				    v[378] = 0
				    @break .level 2
				    
				}
				PFckPtr = TT11  * v[4564] 
				PFckPtr += v[4569] - v[4564]

				v[4004] = PFckPtr + 2
				v[4004] = v[v[4004]]
				@if v[4004] <= 105 {
				    v[PFckPtr].copy v[4001], 2
				    v[4001] .sub v[4588], 2
				    v[4001] .mul v[4001], 2

				    //use TT to optimise
				    TT12 =  v[4001] + v[4002]
				    v[4001] = sqrt(TT12, 100) // using sqrt might be the very reason of the slowness of this loop?

				    //save v[v[4581]] % 10 to some temp var and you vill happy
				    TT12 = v[v[4581]] % 10
				    TT13 = 3601 + v[2065] 

				    v[TT13] = (v[4001] + v[4004] * 150) * 10 + TT12
				    @if TT12 == v[4586] {
					v[TT13] += 2500
					
				    }

				    v[4591] += 1
				    //optimise
				    //v[3609 + v[2065]] = v[v[4581]] / 10
				    TT13 += 8 // since TT13 is 3601 + v[2065]
				    //Now TT13 = 3609 + v[2065]...  
				    v[TT13] = TT11
				    
				}
				
			    } .else bl {
				@break
				
			    }
			    v[4581] += 1
			    
			}
			
			
		    } .else bl {

			@loop 8 .dst v[2065] {
			    @if v[v[4581]] > 0 {

				//opt 28.4.23
				//save v[v[4581]] / 10 to TT11
				TT11 = v[v[4581]] / 10

				@if TT11 == PF_goal_Node {
				    v[v[4600] + TT11 - 1] = PF_current_checking_Node
				    PF_current_checking_Node = TT11
				    v[378] = 0
				    @break .level 2
				    
				}

				PFckPtr = TT11 * v[4564] 
				PFckPtr += v[4569] - v[4564]

				TT12  = PFckPtr + 2
				v[4004] = v[TT12]
				@if v[4004] <= 105 {
				    v[PFckPtr].copy v[4001], 2
				    v[4001] .sub v[4588], 2
				    v[4001] .mul v[4001], 2
				    v[4001] += v[4002]
				    v[4001] = sqrt(v[4001], 100)
				    v[3601 + v[2065]] = (v[4001] + v[4004] * 150) * 10 + v[v[4581]] % 10
				    v[4591] += 1

				    //opt 28.4.23
				    //v[3609 + v[2065]] = v[v[4581]] / 10
				    v[3609 + v[2065]] = TT11
				
				}
				
			    } .else bl {
				@break
				
			    }

			    v[4581] += 1
			    
			}
			
			
		    }

		    var8 = 0
		    v[4003] = v[PF_current_checking_Node - 1 + v[4555]]
		    @loop 8 .dst v[2065] {
			var9 = 3609 + v[2065]
			var9 = v[var9]
			@if var9 > 0 {
			    var10 = 3601 + v[2065]
			    var10 = v[var10]
			    var10 += v[4003]
			    //@call .cev 1772
			    func_pathfinding_open_Node()
			}
			
		    }

		    // "######	add var10 to closelist"
		    v[19] = PF_current_checking_Node
		    v[v[4567] + v[4583]] = v[19]
		    v[4583] += 1
		    v[v[4567]].sortDescending v[4583]
		    var1 = v[4568] + 1
		    v[var1].copy v[v[4568]], v[4582]
		    v[v[4568] + v[4582]] = 0
		    var1 = v[4555] + 1
		    v[var1].copy v[v[4555]], v[4582]
		    v[v[4555] + v[4582]] = 0
		    v[4582] -= 1

		    @if v[4582] <= 0 {
			v[378] = -1
			@break
			
		    }
		    v[v[4555]].sort v[4582] .sync v[v[4568]]
		    PF_current_checking_Node = v[v[4568]]
		    // "######"
		    @if `v[2064] % 24 == 23 {
			PF_done_per_1f = 0 // refresh PF counter
			@wait 0
			
		    }
		    
		}
		
		// refresh deployed agent data after the node searching loop ends 
		refresh_deployed_agent_data()

		v[2070] = v[2075]

		__if DEBUG_BUILD == 1 {
		    v[4592] = 0
		    Temp11 = (PF_current_checking_Node - 1) * v[4564] + v[4569]
		    v[Temp11].copy var1, 2
		    @map[v[501]].setVehiclePos .boat .pos var1, var2 .retain
		    reg2 = boat.scrx
		    reg3 = boat.scry
		    reg3 -= 8
		    v[22..23] += 8

		    @pic[v[2070]].strpic {
			"\PF_current_checking_Node"
			.pos reg2, reg3 .center
			.size 32, 32                .scrollWithMap
			.chromakey 1
			.scale 100
			.trans 50
			.rgbs 100, 100, 100, 100
			.font "", 9
			.spacing 0, 4
			.skin "" .stretch
			.mapLayer 7
			.eraseWhenTransfer
			.affectedByFlash
			.affectedByShake
		    }
		    @if Bool_PF_Wall_Detection .isOn() {
			@if v[2070] == v[341] {
			    v[378] = -1
			    
			}
			
		    }
		    
		}

		v[2875] = v[4595]
		@if `pfagent_AgentBits & AgentBits_FLAG_PF_walldetection_switch {
		    v[341] = v[204] >= 380 ? 512 : 1024
		    @if v[2070] == v[341] {
			v[378] = -1
			
		    }
		    
		}

		// "restore path"
		v[379] = 0
		v[ptr_null].copy v[2066],2 //v[2066..2067] = 0
		v[ptr_null].copy v[4350],31 //v[4350..4380] = 0
		@while PF_current_checking_Node > 0 .dst v[2064] {
		    @if v[2064] > 0 {
			v[2065] = v[v[4600] + PF_current_checking_Node - 1]
			v[2067] = v[2066]
			v[2066] = PF_current_checking_Node - v[2065]
			@if v[2064] >= 10000 {
			    @break
			    
			}
			
		    }


		    @if v[2066] != v[2067] {
			v[2070] += 1
			v[4592] = 0
			Temp11 = (PF_current_checking_Node - 1) * v[4564] + v[4569]
			v[Temp11].copy var1, 2
			@map[v[501]].setVehiclePos .boat .pos var1, var2 .retain
			reg2 = boat.scrx
			reg3 = boat.scry
			reg2 += 8
			/*optimise
			reg3 -= 8
			v[22..23] += 8
			*/

			__if DEBUG_BUILD == 1 {
			    @pic[v[2070]].strpic {
				"\v[2070]"
				.pos reg2, reg3 .center
				.size 32, 32                        .scrollWithMap
				.chromakey 1
				.scale 100
				.trans 10
				.rgbs 200, 200, 100, 100
				.font "", 12 .bold
				.spacing 0, 4
				.skin "" .nobg .noframe .noPadding
				.mapLayer 7
				.eraseWhenTransfer
				.affectedByFlash
				.affectedByShake
			    }
			    
			}


			v[375] = v[2875] % 20

			//opt 27.4.23
			//v[2071] = 4359 - v[375] * 2
			v[2071] = 4359 
			v[2071] -= v[375] * 2 
			reg2.copy v[v[2071]], 2
			// "WP"
			v[2875] += 1
			
		    }
		    PF_current_checking_Node = v[v[4600] + PF_current_checking_Node - 1]
		    @if PF_current_checking_Node == PF_start_Node {
			@break
			
		    }
		    
		}
		
		@if v[2875] > 20 {
		    v[379] = 0
		    v[2875] = 6
		    @loop v[2875] .dst v[2064] {
			@if v[2071] >= 4360 {
			    v[2071] = 4321
			    
			}
			v[2072] = 2873 - v[2064] * 2
			v[v[2071]].copy v[2851], 2
			v[2863].copy v[2861], 2
			v[2865].copy v[2863], 2
			v[2867].copy v[2865], 2
			v[2869].copy v[2867], 2
			v[2871].copy v[2869], 2
			v[2873].copy v[2871], 2
			v[2851].copy v[2873], 2
			v[2071] += 2
			
		    }
		    
		    
		} .else bl {
		    @if v[2875] > 6 {
			v[379] = 0
			v[2875] = 6
			
		    }
		    @loop v[2875] .dst v[2064] {
			v[2072] = 2873 - v[2064] * 2
			v[v[2071]].copy v[2851], 2
			v[2863].copy v[2861], 2
			v[2865].copy v[2863], 2
			v[2867].copy v[2865], 2
			v[2869].copy v[2867], 2
			v[2871].copy v[2869], 2
			v[2873].copy v[2871], 2
			v[2851].copy v[2873], 2
			v[2071] += 2
			
		    }
		    
		    
		}

		/*@if s[1] .isOn() {
		    t[801] .asg "\v[4582]ko" .extract
		    t[801] .cat t[525]
		    @loop v[4582] .dst var1 {
			var2 = v[4568] + var1
			var10 = v[var2]
			t[801] .cat "\var10" .extract
			t[801] .cat t[525]
			
		    }
		    
		    t[801] .toFile "debug_openlist", .utf8
		    t[801] .asg "\v[4583]ko" .extract
		    t[801] .cat t[525]
		    @loop v[4583] .dst var1 {
			var2 = v[4567] + var1
			var10 = v[var2]
			t[801] .cat "\var10" .extract
			t[801] .cat t[525]
			
		    }
		    
		    t[801] .toFile "debug_closelist", .utf8
		    
		}*/


		// from this part seemingly buggy

		v[2861] .sub v[1021], 14
		v[380] = 0
		@if `pfagent_AgentBits & AgentBits_FLAG_PF_walldetection_switch {
		    // "Reset Grouppath"
		    TT1 = Pathfinding_AgentData_head_ptr + 34
		    v[TT1] &= -16777217 //~16777216
		    v[TT1] |= AI_routine_bits_FLAG_1secDelay_PF

		    v[ptr_null].copy v[LEGV_ConstAIselectedListHead],200
		    v[LEGV_ConstAIselectedListHead] = v[4596] + 1
		    v[2880] = LEGV_ConstAIselectedListHead + 1
		    v[2841] = 1
		    
		} .else bl {


		    // If the agent belongs to a Cohort OR the agent team is NOT player
		    //then set the agent cohort to Temp20
		    v[320] = pfagent_Cohort_ID < 11 || v[Pathfinding_AgentData_head_ptr + 100] != 0 ? v[Pathfinding_AgentData_head_ptr + 35] : 0
		    // ptr to agent_AI_routine_bits
		    v[321] = Pathfinding_AgentData_head_ptr + 34

		    // If the agent has cohort AND the Group path flag
		    @if `v[320] > 0 && pfagent_AI_routine_bits & AI_routine_bits_FLAG_GroupPath {

			// "v1=Cohort	v2=Team, 0/1"
			var2 = Pathfinding_AgentData_head_ptr + 100
			var2 = v[var2]

			v[2861].copy v[2961], 15
			@loop v[1012] .dst Temp1 {

			    // "Check Enemy Team List"
			    Ptr20 = Temp1 + v[1145 + var2]
			    @if v[Ptr20] >= 1 {
				Ptr19 = v[Ptr20] * 300
				Ptr19 += 4735

				// "The unit belongs to the selected Cohort"
				@if v[Ptr19] == v[320] {
				    
				    //opt 27.4.23
				    Ptr18 = v[Ptr20] * 300
				    Ptr18 += 4734

				    @if `v[Ptr18] & 49152 { // AI_routine_bits_FLAG_PFcontinue + AI_routine_bits_FLAG_PATHFINDING
					@if `!(v[Ptr18 - 31] & AgentBits_FLAG_PF_walldetection_switch) {

					    var1 = v[Ptr20]
					    v[2880] = LEGV_ConstAIselectedListHead
					    v[2841] = 0
					    v[ptr_null].copy v[LEGV_ConstAIselectedListHead],200 //v[LEGV_ConstAIselectedListHead..LEGV_ConstAIselectedListHead + 199] = 0

					    //CEV.. add agent to AI control list
					    // @call .cev 1747
					    v[v[2880]] = var1
					    v[2880] += 1
					    v[2841] += 1
					    
					    @if v[378] == -1 {
						v[Ptr18] |= AI_routine_bits_FLAG_Pathblocked
						
					    } .else bl {
						v[Ptr18] &= KILL_AI_routine_bits_FLAG_Pathblocked //-8388609//~8388608
						
					    }

					    v[Ptr18] &= -16385//~16384
					    @if v[379] == 1 {
						v[Ptr18] &= -16859137//~16859136
						
					    } .else bl {
						v[Ptr18] |= AI_routine_bits_FLAG_PFcontinue + AI_routine_bits_FLAG_PFskip
						
					    }

					    @if `!(v[Pathfinding_AgentData_head_ptr + 3] & AgentBits_FLAG_walldetected) || v[378] != -1 {
						v[Ptr18] |= 4096
						Temp16 = v[LEGV_ConstAIselectedListHead] * 300 
						Temp16 += 4741
						Temp17 = Temp16 + 14
						Temp17 = max(v[Temp17], 0)
						Temp16 += Temp17 * 2
						v[Temp16].copy v[2851], 2
						v[2961].copy v[2861], 15
						func_pathfinding_move()

					    } .else bl {
						// stop pathfinding
						v[Pathfinding_AgentData_head_ptr + 34] &= AI_routine_bits_KILL_FLAG_PATHFINDING//-16385 ~16384
						
					    }
					    
					}
					
				    }
				    
				}
				
			    }
			    
			}
			
			v[380] = 1
			
		    } .else bl {
			v[ptr_null].copy v[LEGV_ConstAIselectedListHead],200 //v[LEGV_ConstAIselectedListHead..LEGV_ConstAIselectedListHead + 199] = 0
			v[LEGV_ConstAIselectedListHead] = v[4596] + 1
			v[2880] = LEGV_ConstAIselectedListHead + 1
			v[2841] = 1
			
		    }
		    
		}
		// "####"

		//

		@if v[380] == 0 {
		    // redeploy
		    refresh_deployed_agent_data()

		    @if `!(pfagent_AgentBits & AgentBits_FLAG_walldetected) || v[378] != -1 {

			// set up the point coordinate to move
			Temp16 = v[LEGV_ConstAIselectedListHead] * 300 
			Temp16 += 4741
			Temp17 = Temp16 + 14
			Temp17 = max(v[Temp17], 0)
			Temp16 += Temp17 * 2
			v[Temp16].copy v[2851], 2
			// pathfinding movement order
			func_pathfinding_move()
			
			// agent AI_routine_bit
			v[Pathfinding_AgentData_head_ptr + 34] |= AI_routine_bits_FLAG_tracing_flag
			
		    } .else bl {
			// stop pathfinding
			// agent AI_routine_bit
			v[Pathfinding_AgentData_head_ptr + 34] &= AI_routine_bits_KILL_FLAG_PATHFINDING //~16384
			
		    }

		    // flag management after movement order
		    // use buffers as pointers
		    defv pfagent_Ptr_pfagent_AgentBits = __id(pfagent_AgentBits)
		    pfagent_Ptr_pfagent_AgentBits = Pathfinding_AgentData_head_ptr + 3

		    defv pfagent_Ptr_AI_routine_bits = __id(pfagent_AI_routine_bits)
		    pfagent_Ptr_AI_routine_bits = Pathfinding_AgentData_head_ptr + 34


		    // 
		    @if v[379] == 0 {
			v[pfagent_Ptr_AI_routine_bits] |= AI_routine_bits_FLAG_PFcontinue + AI_routine_bits_FLAG_PFskip
			
		    } .else bl {
			v[pfagent_Ptr_AI_routine_bits] &= AI_routine_bits_KILL_FLAG_PFcontinue //~32768
			v[pfagent_Ptr_pfagent_AgentBits] &= -33554433//~33554432
			
		    }

		    // 
		    @if v[378] == -1 {
			v[pfagent_Ptr_AI_routine_bits] |= AI_routine_bits_FLAG_Pathblocked
			v[pfagent_Ptr_pfagent_AgentBits] &= -33554433 //~33554432
			
		    } .else bl {
			v[pfagent_Ptr_AI_routine_bits] &= -8388609 //~8388608
			
		    }
		    
		}
		
	    }
	    
	}
}


// Terrible "path" finding process before going to itch

__fn func_pathfinding_retarded() {

	// "#移動先壁チェック"
	s[279].on
	v[342] = Pathfinding_AgentData_head_ptr + 21
	v[v[342]].copy v[303], 2
	@if v[304] < -30 {
	    // "Up"
	    @if v[303] > 30 {
		// "Right"
		v[4586] = 3
		
	    } .else bl {
		@if v[303] < -30 {
		    // "Left"
		    v[4586] = 1
		    
		} .else bl {
		    v[4586] = 2
		    
		}
		
	    }
	    
	} .else bl {
	    @if v[304] > 30 {
		// "Down"
		@if v[303] > 30 {
		    // "Right"
		    v[4586] = 5
		    
		} .else bl {
		    @if v[303] < -30 {
			// "Left"
			v[4586] = 7
			
		    } .else bl {
			v[4586] = 6
			
		    }
		    
		}
		
	    } .else bl {
		@if v[303] > 30 {
		    // "Right"
		    v[4586] = 4
		    
		} .else bl {
		    @if v[303] < -30 {
			// "Left"
			v[4586] = 8
			
		    }
		    
		}
		
	    }
	    
	}
	// "Goal Node"
	v[342] = Pathfinding_AgentData_head_ptr + 41
	v[317] = v[342] + 14
	v[317] = max(v[v[317]], 0)
	v[342] += v[317] * 2
	v[v[342]].copy var1, 2
	@call .cev 2000
	v[21].copy Temp11, 2
	Temp11 = (Temp11 - v[69]) / 2
	v[312] = (v[312] - v[70]) / 2
	v[12] = Temp11 + v[312] * v[433] + 1

	// "Start Node"
	v[342] = Pathfinding_AgentData_head_ptr + 26
	v[v[342]].copy Temp11, 2
	Temp11 = (Temp11 - v[69]) / 2
	v[312] = (v[312] - v[70]) / 2
	var1 = Temp11 + v[312] * v[433] + 1

	/* "#
	v1=start
	v2=goal"*/
	// "#""INIT"
	v[4593] = Bool_PF_Wall_Detection == 1 ? 2 : 6
	v[4592] = v[4593] + 1
	v[4595] = 0
	v[4584..4585] = 0
	v[4582..4583] = 0
	var1.copy PF_start_Node, 2
	v[1301].copy v[v[4568]], 200
	v[1301].copy v[v[4567]], 200
	PF_current_checking_Node = PF_start_Node
	var10 = PF_start_Node

	// "######add var10 to openlist"
	v[v[4568] + v[4582]] = var10
	v[4582] += 1
	v[v[4568]].sortDescending v[4582]
	// "######"
	v[4588] = (PF_goal_Node - 1) * v[4564] + v[4569]
	v[v[4588]].copy v[4588], 2

	// Main node searching Loop
	@loop 64 .dst v[2064] {
	    v[4581] = (PF_current_checking_Node - 1) * v[4564] + v[4569] + 11
	    v[3601..3608] = 999999999
	    v[4591] = 0
	    v[3601].sort v[4591] .sync v[3609]
	    v[4591] /= 2
	    @loop v[4591] .dst v[2065] {

		// what the fugg this part doing? Why didn't you leave comments to eggsplain what is going on? what a tard
		// v[4001] = v[3609 + v[2065]]
		// v[4002] = v[3601 + v[2065]]
		v[4001] = 3609 + v[2065]
		v[4002] = 3601 + v[2065]
		v[4001].deref v[4001],2

		v[4020] = v[(PF_current_checking_Node - 1) * v[4564] + v[4569] + 10 + v[4001]] / 10
		@if v[4020] == PF_goal_Node {
		    @break .level 2
		    
		} .else bl {
		    v[371] = 0
		    Temp10 = v[4583]
		    Temp9 = v[4567]
		    Temp10 += Temp9
		    @while Temp9 <= Temp10 {
			Temp11 = (Temp9 + Temp10) 
			Temp11 /= 2
			@if v[Temp11] == v[4020] {
			    v[371] = 1
			    @break
			    
			} .else bl {
			    @if v[Temp11] < v[4020] {
				Temp10 = Temp11 - 1
				
			    } .else bl {
				Temp9 = Temp11 + 1
				
			    }
			    
			}
			
		    }
		    
		    @if v[371] != 1 {
			v[4001] = v[4002] % 10
			v[4592] += 1
			@if v[4586] != v[4001] {
			    @if v[4592] >= v[4593] {
				v[4592] = 0
				Temp11 = (v[4020] - 1) * v[4564] + v[4569]
				v[Temp11].copy var1, 2
				@map[v[501]].setVehiclePos .boat .pos var1, v[12] .retain
				v[22] = boat.scrx
				v[23] = boat.scry
				v[23] -= 8
				v[22..23] += 8
				v[22].copy v[2851], 2
				// "WP"
				v[2863].copy v[2861], 2
				v[2865].copy v[2863], 2
				v[2867].copy v[2865], 2
				v[2869].copy v[2867], 2
				v[2871].copy v[2869], 2
				v[2873].copy v[2871], 2
				v[2851].copy v[2873], 2
				v[4595] += 1
				v[4586] = v[4002] % 10
				
			    }
			    
			}
			@break
			
		    }
		    @if v[4595] >= 6 {
			@break
			
		    }
		    
		}
		
	    }
	    
	    @if `v[4591] == v[2065] + 1 {
		@break
		
	    }

	    // "check if NodeV[3609] is in close list"
	    @if v[371] != 1 {
		var10 = PF_current_checking_Node
		// "######	add var10 to closelist"
		v[v[4567] + v[4583]] = var10
		v[4583] += 1
		v[v[4567]].sortDescending v[4583]
		
	    }

	    // "######"
	    PF_current_checking_Node = v[4020]
	    @if v[4595] >= 6 {
		@break
		
	    }
	    
	}

	v[2875] = v[4595]
	v[2861] .sub v[1021], 14
	v[380] = 0
	@if `v[Pathfinding_AgentData_head_ptr + 3] & 33554432 {
	    v[LEGV_ConstAIselectedListHead..LEGV_ConstAIselectedListHead + 199] = 0
	    v[LEGV_ConstAIselectedListHead] = v[4596] + 1
	    v[2880] = LEGV_ConstAIselectedListHead + 1
	    v[2841] = 1
	    
	} .else bl {
	    v[320] = v[Pathfinding_AgentData_head_ptr + 35] < 11 || v[Pathfinding_AgentData_head_ptr + 100] != 0 ? v[Pathfinding_AgentData_head_ptr + 35] : 0
	    @if `v[320] > 0 {
		// "v1=Cohort	v2=Team, 0/1"
		v[12] = v[Pathfinding_AgentData_head_ptr + 100]
		v[2861].copy v[2961], 15
		@loop v[1012] .dst Temp1 {
		    // "Check Enemy Team List"
		    v[300] = Temp1 + v[1145 + v[12]]
		    @if v[v[300]] >= 1 {
			Ptr19 = v[v[300]] * 300
			Ptr19 += 4735
			// "The unit belongs to the selected Cohort"
			@if v[Ptr19] == v[320] {
			    v[298] = v[v[300]] * 300 + 4734
			    @if `v[v[298]] & 16384 {
				v[LEGV_ConstAIselectedListHead..LEGV_ConstAIselectedListHead + 199] = 0
				v[2880] = LEGV_ConstAIselectedListHead
				v[2841] = 0
				var1 = v[v[300]]
				@call .cev 1747
				v[v[298]] |= 4096
				v[v[298]] &= ~16384
				v[v[298]] &= ~8388608
				v[v[298]] &= ~32768
				v[316] = v[LEGV_ConstAIselectedListHead] * 300 + 4741
				v[317] = v[316] + 14
				v[317] = max(v[v[317]], 0)
				v[316] += v[317] * 2
				v[v[316]].copy v[2851], 2
				v[2961].copy v[2861], 15
				@call .cev 1771
				
			    }
			    
			}
			
		    }
		    
		}
		
		v[380] = 1
		
	    } .else bl {
		v[LEGV_ConstAIselectedListHead..LEGV_ConstAIselectedListHead + 199] = 0
		v[LEGV_ConstAIselectedListHead] = v[4596] + 1
		v[2880] = LEGV_ConstAIselectedListHead + 1
		v[2841] = 1
		
	    }
	    
	}
	// "####"
	@if v[380] == 0 {
	    v[316] = v[LEGV_ConstAIselectedListHead] * 300 + 4741
	    v[317] = v[316] + 14
	    v[317] = max(v[v[317]], 0)
	    v[316] += v[317] * 2
	    v[v[316]].copy v[2851], 2
	    @call .cev 1771
	    v[Pathfinding_AgentData_head_ptr + 34] |= 4096
	    v[Pathfinding_AgentData_head_ptr + 34] &= ~8388608
	    v[Pathfinding_AgentData_head_ptr + 34] &= ~32768
	    
	}
	v[Pathfinding_AgentData_head_ptr + 3] &= ~33554432
	s[279].off
	@wait 0

}
