
__fn refresh_deployed_agent_data {
	v[Pathfinding_AgentData_head_ptr].copy Head_of_Agent_Buffer_PF, 64
}

__fn func_pathfinding_Astar() {
	// deploy to 
	refresh_deployed_agent_data()

	__if DEBUG_BUILD == 1 {
	    @pic[1..800].erase
	    
	}

	// "#移動先壁チェック"
	//TT2 = Pathfinding_AgentData_head_ptr + 21
	//v[TT2].copy Temp3, 2

	pfagent_MoveUvectorX.copy Temp3, 2
		@if Temp4 < -30 {
			// "Up"
			@if Temp3 > 30 {
				// "Right"
				v[4586] = 3

			} .else bl {
				@if Temp3 < -30 {
					// "Left"
					v[4586] = 1

				} .else bl {
					v[4586] = 2

				}

			}

		} .else bl {
			@if Temp4 > 30 {
				// "Down"
				@if Temp3 > 30 {
					// "Right"
					v[4586] = 5

				} .else bl {
					@if Temp3 < -30 {
						// "Left"
						v[4586] = 7

					} .else bl {
						v[4586] = 6

					}

				}

			} .else bl {
				@if Temp3 > 30 {
					// "Right"
					v[4586] = 4

				} .else bl {
					@if Temp3 < -30 {
						// "Left"
						v[4586] = 8

					}

				}

			}

		}

	// "Goal Node setting start"
	 pfagent_TargetAgentID = pfagent_AgentBits & AgentBits_FLAG_ForcemoveFlag ? 0 : pfagent_TargetAgentID

	//The Agent has any Target agent?
	@if  pfagent_TargetAgentID > 0 { //Yes, it does

	    //Then get Target Agent position into var1 var2
	    TT2 =  pfagent_TargetAgentID * 300 
	    TT2 += 4726
	    v[TT2].copy Temp11, 2 // FIXED!
	    
	} .else bl { // No, it doesn't

	    // Then get Target Agent position into var1 var2
	    //Temp17 = TT2 + 14
	    //TT2 = Pathfinding_AgentData_head_ptr + 41
	    //Temp17 = max(v[Temp17], 0)
	    //TT2 += Temp17 * 2
	    //v[TT2].copy var1, 2

	    TT2 =__id(pfagent_HoldPointX) // Pathfinding_AgentData_head_ptr + 41
	    Temp17 = max(pfagent_LeftWPtoChase, 0)
	    TT2 += Temp17 * 2
	    v[TT2].copy var1, 2

	    // convert into tile coordinate - maybe you can deal with this without this func if the PF agent has the target agent
	    @call .cev 2000
	    reg1.copy Temp11, 2

	    
	}

	// The goal node is set, now to run actual node check process
	// "safety in order not to set out of map as a goal node"
	@if `between(reg2, v[70], v[72]) {
	    @if `between(reg1, v[69], v[71]) {

		Temp11.sub v[69],2
		Temp11.div N2,2
		// v[311..312] /= 2

		//opt 27.4.23
		//var2 = Temp11 + v[312] * v[433] + 1
		var2 = Temp11 + 1
		var2 += v[312] * v[433]

		// "Start Node"
		//TT2 = Pathfinding_AgentData_head_ptr + 26
		//v[TT2].copy Temp11, 2
		pfagent_MapX.copy Temp11, 2
		Temp11.sub v[69],2
		Temp11.div N2,2

		// var1 = start node id
		var1 = Temp11 + 1 
		var1 += v[312] * v[433]
		/* "#v1=start	v2=goal"*/
		// "#""INIT"
		v[4593] = Bool_PF_Wall_Detection == 1 ? 2 : 6
		v[4592] = v[4593] + 1
		v[4595] = 0

		v[ptr_null].copy v[4582],4
		var1.copy PF_start_Node, 2
		
		v[ptr_null].copy v[v[4568]], PF_init_Range 


		// check from start node
		PF_current_checking_Node = PF_start_Node
		var10 = PF_start_Node

		// "######add start Node to openlist"
		v[v[4568] + v[4582]] = var10
		v[4582] += 1

		v[v[4568]].sortDescending v[4582]
		v[4588] = (PF_goal_Node - 1) * Const_save_var_NodeDataSize + Const_save_var_NodeArrayHead
		v[v[4588]].copy v[4588], 2
		v[341] = v[204] >= 380 ? 512 : 1024
		v[378] = -1

		@loop v[341] .dst v[2064] {

			v[2075] = v[2064] + 1
			v[4581] = (PF_current_checking_Node - 1) * Const_save_var_NodeDataSize + Const_save_var_NodeArrayHead + 11
			//ACHTUNG - need to change into .copy proc
			v[3601..3608] = 999999999

			//ACHTUNG - need to change into .copy proc   
			v[ptr_null].copy v[3609],8 // v[3609..3617] = 0
			v[ptr_null].copy v[4591],1 // v[4591] = 0

			// "Euclid"

			// These parts using MapIndex variables that were initially set in the Classic version.
			// So it can be unexpected roots of bugs (all classic features must be eventually removed, otherwise it will annoy you later)
			@if v[2064] == 0 {
				// "First attempt"
				@loop 8 .dst v[2065] {
						@if v[v[4581]] > 0 {
							//opt 28.4.23
							TT11 = v[v[4581]] / 10

							@if TT11  == PF_goal_Node { // reached goal Node!
								v[Const_save_var_PFNodesLinkMINUS1 + TT11] = PF_current_checking_Node
								PF_current_checking_Node = TT11 
								v[378] = 0
								@break .level 2
								
							}

							PFckPtr = TT11  * Const_save_var_NodeDataSize 
							PFckPtr += Const_save_var_NodeArrayHead - Const_save_var_NodeDataSize

							v[4004] = PFckPtr + 2
							v[4004] = v[v[4004]]
							@if v[4004] <= 105 {
									v[PFckPtr].copy v[4001], 2
									v[4001] .sub v[4588], 2
									v[4001] .mul v[4001], 2

									//use TT to optimise
									TT12 =  v[4001] + v[4002]
									v[4001] = sqrt(TT12, 100) // using sqrt might be the reason of the slowness of this loop?

									TT12 = v[v[4581]] % 10
									TT13 = 3601 + v[2065] 

									v[TT13] = (v[4001] + v[4004] * 150) * 10 + TT12
									@if TT12 == v[4586] {
										v[TT13] += 2500
										
									}

									val_add(v[4591],N1) // v[4591] += 1
									//optimise
									//v[3609 + v[2065]] = v[v[4581]] / 10
									TT13 += 8 // since TT13 is 3601 + v[2065]
									//Now TT13 = 3609 + v[2065]...  
									ptr_asg(TT13,TT11) // v[TT13] = TT11
									
							}
							
						} .else bl {
					@break
					
						}
						increment_var(v[4581]) // v[4581] += 1
						
				}
				
				
			} .else bl {

		@loop 8 .dst v[2065] {
				@if v[v[4581]] > 0 {

			//opt 28.4.23
			//save v[v[4581]] / 10 to TT11
			TT11 = v[v[4581]] / 10

			@if TT11 == PF_goal_Node {
					v[Const_save_var_PFNodesLinkMINUS1 + TT11] = PF_current_checking_Node
					PF_current_checking_Node = TT11
					v[378] = 0
					@break .level 2
					
			}

			PFckPtr = TT11 * Const_save_var_NodeDataSize 
			PFckPtr += Const_save_var_NodeArrayHead - Const_save_var_NodeDataSize

			TT12  = PFckPtr + 2
			v[4004] = v[TT12]
			@if v[4004] <= 105 {
					v[PFckPtr].copy v[4001], 2
					v[4001] .sub v[4588], 2
					v[4001] .mul v[4001], 2
					v[4001] += v[4002]
					v[4001] = sqrt(v[4001], 100)
					v[3601 + v[2065]] = (v[4001] + v[4004] * 150) * 10 + v[v[4581]] % 10
					v[4591] += 1

					//opt 28.4.23
					//v[3609 + v[2065]] = v[v[4581]] / 10
					v[3609 + v[2065]] = TT11
			
			}
			
				} .else bl {
			@break
			
				}

				increment_var(v[4581]) // v[4581] += 1
				
		}
		
		
			}

			var8 = 0
			v[4003] = v[PF_current_checking_Node - 1 + v[4555]]
			@loop 8 .dst v[2065] {
				var9 = 3609 + v[2065]
				var9 = v[var9]
				@if var9 > 0 {
						var10 = 3601 + v[2065]
						var10.deref var10,1 // var10 = v[var10]
						val_add(var10,v[4003]) // var10 += v[4003]
						//@call .cev 1772
						func_pathfinding_open_Node()
				}
		
			}

			// "######	add var10 to closelist"
			v[19] = PF_current_checking_Node
			v[Const_save_var_ClosedNodesListHead + v[4583]] = v[19]

			val_add(v[4583],N1) // v[4583] += 1
			v[Const_save_var_ClosedNodesListHead].sortDescending v[4583]

			var1 = v[4568] + 1
			v[var1].copy v[v[4568]], v[4582]
			// v[v[4568] + v[4582]] = 0
			var2 = v[4568] + v[4582]
			v[ptr_null].copy v[var2].1

			var1 = v[4555] + 1
			v[var1].copy v[v[4555]], v[4582]
			// v[v[4555] + v[4582]] = 0
			var2 = v[4555] + v[4582]
			v[ptr_null].copy v[var2].1

			val_sub(v[4582],N1) // v[4582] -= 1

			@if v[4582] <= 0 {
				v[378] = -1
				@break
		
			}
			v[v[4555]].sort v[4582] .sync v[v[4568]]
			PF_current_checking_Node = v[v[4568]]
			// "######"
			@if `v[2064] % 24 == 23 {
				// refresh PF counter
				v[ptr_null].copy PF_done_per_1f,1 // PF_done_per_1f = 0 
				@wait 0
		
			}
			
		}
		
		// refresh deployed agent data after the node searching loop ends 
		refresh_deployed_agent_data()

		val_asg(v[2070],v[2075]) // v[2070] = v[2075]

		__if DEBUG_BUILD == 1 {
		    v[4592] = 0
		    Temp11 = (PF_current_checking_Node - 1) * Const_save_var_NodeDataSize + Const_save_var_NodeArrayHead
		    v[Temp11].copy var1, 2
		    @map[v[501]].setVehiclePos .boat .pos var1, var2 .retain
		    reg2 = boat.scrx
		    reg3 = boat.scry
		    reg3 -= 8
		    v[22..23] += 8

		    @pic[v[2070]].strpic {
					"\PF_current_checking_Node"
					.pos reg2, reg3 .center
					.size 32, 32                .scrollWithMap
					.chromakey 1
					.scale 100
					.trans 50
					.rgbs 100, 100, 100, 100
					.font "", 9
					.spacing 0, 4
					.skin "" .stretch
					.mapLayer 7
					.eraseWhenTransfer
					.affectedByFlash
					.affectedByShake
		    }
		    @if Bool_PF_Wall_Detection .isOn() {
					@if v[2070] == v[341] {
							v[378] = -1
							
					}
			
		    }
		    
		}

		v[2875] = v[4595]
		@if `pfagent_AgentBits & AgentBits_FLAG_PF_walldetection_switch {
		    v[341] = v[204] >= 380 ? 512 : 1024
		    @if v[2070] == v[341] {
					v[378] = -1
			
		    }
		    
		}

		// "restore path"
		vname[Adr_PFWayPointDeployArray_Head], "PFWayPointDeployArray_Head"
		restore_path_from_nodes(PF_start_Node,PF_current_checking_Node)
		v[2071] = Adr_PFWayPointDeployArray_Head

		// set waypoints to the agent
		@loop v[2875] .dst v[2064] {
			v[v[2071]].copy v[2851], 2
			v[2863].copy v[2861], 2
			v[2865].copy v[2863], 2
			v[2867].copy v[2865], 2
			v[2869].copy v[2867], 2
			v[2871].copy v[2869], 2
			v[2873].copy v[2871], 2
			v[2851].copy v[2873], 2
			v[2071] += 2
			
		}
		
		// set to the agent waypoint array
		/*
		@if v[2875] > 20 { // sofucking many WP 
		    v[379] = 0
		    v[2875] = 6
		    @loop v[2875] .dst v[2064] {
					@if v[2071] >= 4360 {
							v[2071] = 4321
							
					}
					v[2072] = 2873 - v[2064] * 2
					v[v[2071]].copy v[2851], 2
					v[2863].copy v[2861], 2
					v[2865].copy v[2863], 2
					v[2867].copy v[2865], 2
					v[2869].copy v[2867], 2
					v[2871].copy v[2869], 2
					v[2873].copy v[2871], 2
					v[2851].copy v[2873], 2
					v[2071] += 2
					
		    }
		    
		    
		} .else bl {
		    @if v[2875] > 6 {
					v[379] = 0
					v[2875] = 6
					
		    }

		    @loop v[2875] .dst v[2064] {
					v[v[2071]].copy v[2851], 2
					v[2863].copy v[2861], 2
					v[2865].copy v[2863], 2
					v[2867].copy v[2865], 2
					v[2869].copy v[2867], 2
					v[2871].copy v[2869], 2
					v[2873].copy v[2871], 2
					v[2851].copy v[2873], 2
					v[2071] += 2
					
		    }
		    
		    
		}
		*/

		/*
		@if s[1] .isOn() {
		    t[801] .asg "\v[4582]ko" .extract
		    t[801] .cat t[525]
		    @loop v[4582] .dst var1 {
			var2 = v[4568] + var1
			var10 = v[var2]
			t[801] .cat "\var10" .extract
			t[801] .cat t[525]
			
		    }
		    
		    t[801] .toFile "debug_openlist", .utf8
		    t[801] .asg "\v[4583]ko" .extract
		    t[801] .cat t[525]
		    @loop v[4583] .dst var1 {
			var2 = Const_save_var_ClosedNodesListHead + var1
			var10 = v[var2]
			t[801] .cat "\var10" .extract
			t[801] .cat t[525]
			
		    }
		    
		    t[801] .toFile "debug_closelist", .utf8
		    
		}
		*/


		// from this part seemingly buggy
				pf_agent_move()
	    }
	    
	}
}


// Terrible "path" finding process before going to itch

__fn func_pathfinding_retarded() {

	// "#移動先壁チェック"
	s[279].on
	v[342] = Pathfinding_AgentData_head_ptr + 21
	v[v[342]].copy v[303], 2
	@if v[304] < -30 {
	    // "Up"
	    @if v[303] > 30 {
		// "Right"
		v[4586] = 3
		
	    } .else bl {
		@if v[303] < -30 {
		    // "Left"
		    v[4586] = 1
		    
		} .else bl {
		    v[4586] = 2
		    
		}
		
	    }
	    
	} .else bl {
	    @if v[304] > 30 {
		// "Down"
		@if v[303] > 30 {
		    // "Right"
		    v[4586] = 5
		    
		} .else bl {
		    @if v[303] < -30 {
			// "Left"
			v[4586] = 7
			
		    } .else bl {
			v[4586] = 6
			
		    }
		    
		}
		
	    } .else bl {
		@if v[303] > 30 {
		    // "Right"
		    v[4586] = 4
		    
		} .else bl {
		    @if v[303] < -30 {
			// "Left"
			v[4586] = 8
			
		    }
		    
		}
		
	    }
	    
	}
	// "Goal Node"
	v[342] = Pathfinding_AgentData_head_ptr + 41
	v[317] = v[342] + 14
	v[317] = max(v[v[317]], 0)
	v[342] += v[317] * 2
	v[v[342]].copy var1, 2
	@call .cev 2000
	v[21].copy Temp11, 2
	Temp11 = (Temp11 - v[69]) / 2
	v[312] = (v[312] - v[70]) / 2
	v[12] = Temp11 + v[312] * v[433] + 1

	// "Start Node"
	v[342] = Pathfinding_AgentData_head_ptr + 26
	v[v[342]].copy Temp11, 2
	Temp11 = (Temp11 - v[69]) / 2
	v[312] = (v[312] - v[70]) / 2
	var1 = Temp11 + v[312] * v[433] + 1

	/* "#
	v1=start
	v2=goal"*/
	// "#""INIT"
	v[4593] = Bool_PF_Wall_Detection == 1 ? 2 : 6
	v[4592] = v[4593] + 1
	v[4595] = 0
	v[4584..4585] = 0
	v[4582..4583] = 0
	var1.copy PF_start_Node, 2
	v[1301].copy v[v[4568]], 200
	v[1301].copy v[Const_save_var_ClosedNodesListHead], 200
	PF_current_checking_Node = PF_start_Node
	var10 = PF_start_Node

	// "######add var10 to openlist"
	v[v[4568] + v[4582]] = var10
	v[4582] += 1
	v[v[4568]].sortDescending v[4582]
	// "######"
	v[4588] = (PF_goal_Node - 1) * Const_save_var_NodeDataSize + Const_save_var_NodeArrayHead
	v[v[4588]].copy v[4588], 2

	// Main node searching Loop
	@loop 64 .dst v[2064] {
	    v[4581] = (PF_current_checking_Node - 1) * Const_save_var_NodeDataSize + Const_save_var_NodeArrayHead + 11
	    v[3601..3608] = 999999999
	    v[4591] = 0
	    v[3601].sort v[4591] .sync v[3609]
	    v[4591] /= 2
	    @loop v[4591] .dst v[2065] {

		// what the fugg this part doing? Why didn't you leave comments to eggsplain what is going on? what a tard
		// v[4001] = v[3609 + v[2065]]
		// v[4002] = v[3601 + v[2065]]
		v[4001] = 3609 + v[2065]
		v[4002] = 3601 + v[2065]
		v[4001].deref v[4001],2

		v[4020] = v[(PF_current_checking_Node - 1) * Const_save_var_NodeDataSize + Const_save_var_NodeArrayHead + 10 + v[4001]] / 10
		@if v[4020] == PF_goal_Node {
		    @break .level 2
		    
		} .else bl {
		    v[371] = 0
		    Temp10 = v[4583]
		    Temp9 = Const_save_var_ClosedNodesListHead
		    Temp10 += Temp9
		    @while Temp9 <= Temp10 {
			Temp11 = (Temp9 + Temp10) 
			Temp11 /= 2
			@if v[Temp11] == v[4020] {
			    v[371] = 1
			    @break
			    
			} .else bl {
			    @if v[Temp11] < v[4020] {
				Temp10 = Temp11 - 1
				
			    } .else bl {
				Temp9 = Temp11 + 1
				
			    }
			    
			}
			
		    }
		    
		    @if v[371] != 1 {
			v[4001] = v[4002] % 10
			v[4592] += 1
			@if v[4586] != v[4001] {
			    @if v[4592] >= v[4593] {
				v[4592] = 0
				Temp11 = (v[4020] - 1) * Const_save_var_NodeDataSize + Const_save_var_NodeArrayHead
				v[Temp11].copy var1, 2
				@map[v[501]].setVehiclePos .boat .pos var1, v[12] .retain
				v[22] = boat.scrx
				v[23] = boat.scry
				v[23] -= 8
				v[22..23] += 8
				v[22].copy v[2851], 2
				// "WP"
				v[2863].copy v[2861], 2
				v[2865].copy v[2863], 2
				v[2867].copy v[2865], 2
				v[2869].copy v[2867], 2
				v[2871].copy v[2869], 2
				v[2873].copy v[2871], 2
				v[2851].copy v[2873], 2
				v[4595] += 1
				v[4586] = v[4002] % 10
				
			    }
			    
			}
			@break
			
		    }
		    @if v[4595] >= 6 {
			@break
			
		    }
		    
		}
		
	    }
	    
	    @if `v[4591] == v[2065] + 1 {
		@break
		
	    }

	    // "check if NodeV[3609] is in close list"
	    @if v[371] != 1 {
		var10 = PF_current_checking_Node
		// "######	add var10 to closelist"
		v[Const_save_var_ClosedNodesListHead + v[4583]] = var10
		v[4583] += 1
		v[Const_save_var_ClosedNodesListHead].sortDescending v[4583]
		
	    }

	    // "######"
	    PF_current_checking_Node = v[4020]
	    @if v[4595] >= 6 {
		@break
		
	    }
	    
	}

	v[2875] = v[4595]
	v[2861] .sub v[1021], 14
	v[380] = 0
	@if `v[Pathfinding_AgentData_head_ptr + 3] & AgentBits_FLAG_PF_walldetection_switch {
	    v[LEGV_ConstAIselectedListHead..LEGV_ConstAIselectedListHead + 199] = 0
	    v[LEGV_ConstAIselectedListHead] = v[4596] + 1
	    v[2880] = LEGV_ConstAIselectedListHead + 1
	    v[2841] = 1
	    
	} .else bl {
	    v[320] = v[Pathfinding_AgentData_head_ptr + 35] < 11 || v[Pathfinding_AgentData_head_ptr + 100] != 0 ? v[Pathfinding_AgentData_head_ptr + 35] : 0
	    @if `v[320] > 0 {
				// "v1=Cohort	v2=Team, 0/1"
				v[12] = v[Pathfinding_AgentData_head_ptr + 100]
				v[2861].copy v[2961], 15
				@loop v[1012] .dst Temp1 {
						// "Check Enemy Team List"
						v[300] = Temp1 + v[1145 + v[12]]
						@if v[v[300]] >= 1 {
							Ptr19 = v[v[300]] * 300
							Ptr19 += 4735
							// "The unit belongs to the selected Cohort"
							@if v[Ptr19] == v[320] {
										v[298] = v[v[300]] * 300 + 4734
									@if `v[v[298]] & 16384 {
										v[LEGV_ConstAIselectedListHead..LEGV_ConstAIselectedListHead + 199] = 0
										v[2880] = LEGV_ConstAIselectedListHead
										v[2841] = 0
										var1 = v[v[300]]
										@call .cev 1747
										v[v[298]] |= 4096
										v[v[298]] &= ~16384
										v[v[298]] &= ~8388608
										v[v[298]] &= ~32768
										v[316] = v[LEGV_ConstAIselectedListHead] * 300 + 4741
										v[317] = v[316] + 14
										v[317] = max(v[v[317]], 0)
										v[316] += v[317] * 2
										v[v[316]].copy v[2851], 2
										v[2961].copy v[2861], 15
										// @call .cev 1771
										func_pathfinding_move()
										
									}
									
							}
					
						}
						
				}
				
				v[380] = 1
				
	    } .else bl {
		v[LEGV_ConstAIselectedListHead..LEGV_ConstAIselectedListHead + 199] = 0
		v[LEGV_ConstAIselectedListHead] = v[4596] + 1
		v[2880] = LEGV_ConstAIselectedListHead + 1
		v[2841] = 1
		
	    }
	    
	}

	// "####"
	@if v[380] == 0 {
	    v[316] = v[LEGV_ConstAIselectedListHead] * 300 + 4741
	    v[317] = v[316] + 14
	    v[317] = max(v[v[317]], 0)
	    v[316] += v[317] * 2
	    v[v[316]].copy v[2851], 2
	    // @call .cev 1771
			func_pathfinding_move()
			TT1 = Pathfinding_AgentData_head_ptr + 34
	    v[TT1] |= 4096
	    v[TT1] &= ~8388608
	    v[TT1] &= ~32768
	    
	}
	v[Pathfinding_AgentData_head_ptr + 3] &= ~AgentBits_FLAG_PF_walldetection_switch
	s[279].off
	@wait 0

}

