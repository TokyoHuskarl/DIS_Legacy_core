

// maybe movement order itself should be combined in one

__fn func_pathfinding_move(){
	// "移動指示	Center(x.y)=(wheretox,wheretoy)"

	v[2878] = v[1212]
	v[390] = 0
	@if v[2875] >= 1 {
	    // "WPをとおる"
	    v[2863].copy v[2861], 2
	    v[2865].copy v[2863], 2
	    v[2867].copy v[2865], 2
	    v[2869].copy v[2867], 2
	    v[2871].copy v[2869], 2
	    v[2873].copy v[2871], 2
	    // "#Set 移動するX"
	    // "#Set 移動するY"
	    v[2851].copy v[2873], 2
	    
	}

	// experimental - check if the target coordinate is in map or not
	//to deal with the crash bug in 1.162BETA2
	macro_ck_if_given_rel_coord_is_inside_map(v[2851],v[2852])

	// if the coord is inside map...
	@if reg1 != 1 {
		// then start the movementa order
		@loop .inf() {
		    @if v[v[2878]] == 0 {
			// "とぎれた"
			@break
			
		    }
		    // "配列ゲット"
		    Temp1 = v[v[2878]] * 300 
		    Temp1 += 4700
		    Ptr20 = Temp1 + 242
		    v[299] = Temp1 + 41
		    v[298] = Temp1 + 42
		    v[297] = Temp1 + 18
		    Ptr15 = Temp1 + 241
		    v[294] = Temp1 + 55
		    v[629] = Temp1 + 29
		    @if v[v[297]] > 0 {
			// "if you have obj"
			@if v[Ptr15] == 2 {
			    v[Ptr20] = 2
			    
			} .else bl {
			    v[Ptr20] = 3
			    @if `v[Temp1 + 3] & AgentBits_FLAG_PF_walldetection_switch {
				
			    } .else bl {
				v[Temp1 + 3] &= -16777217//~16777216
				
			    }
			    
			}
			@if `!(v[Temp1 + 3] & AgentBits_FLAG_ForcemoveFlag) {
			    @if v[2875] == 0 {
				v[Ptr20] = 2
				
			    }
			    
			}
			
		    }
		    @if s[279] .isOn() {
			v[Ptr20] = 1
			v[Temp1 + 3] &= -16777217//~16777216
			@if `v[Temp1 + 3] & AgentBits_FLAG_PF_walldetection_switch {
			    v[Temp1 + 3] |= AgentBits_FLAG_walldetected
			    v[Temp1 + 34] |= AI_routine_bits_FLAG_Pathblocked
			    
			}
			
		    }
		    @if v[2875] >= 1 {
			v[293] = 2873
			v[293] -= v[2875] * 2
			@loop v[2875] {
			    v[v[293]].copy v[v[299]], 2
			    v[293] += 2
			    v[299] += 2
			    
			}
			
			v[v[293]].copy v[v[299]], 2
			// "#Set 現在目指してるWPと総WP数"
			v[v[294]] = v[2875]
			v[2873] .add v[2855], 2
			
		    } .else bl {
			// "#Set 移動するX"
			v[v[299]] = v[2851]
			// "#Set 移動するY"
			v[v[298]] = v[2852]
			// "#Set 現在目指してるWPと総WP数"
			v[v[294]] = -1
			v[2851] .add v[2855], 2
			
		    }
		    v[293] = Temp1 + 245
		    v[v[293]] = 0
		    // "Make 2nd line"
		    v[390] += 1
		    v[390] %= v[2859]
		    @if v[390] == 0 {
			@if v[2875] >= 1 {
			    v[2853].copy v[2873], 2
			    v[2873] .add v[2857], 2
			    
			} .else bl {
			    v[2853].copy v[2851], 2
			    v[2851] .add v[2857], 2
			    
			}
			v[2851].copy v[2853], 2
			
		    }
		    @if `v[Temp1 + 1] <= 8 {
			v[Temp1 + 3] = v[Temp1 + 241] <= 4 ? [v[Temp1 + 3] | AgentBits_FLAG_EnableBasicAI, v[Temp1 + 3] | AgentBits_FLAG_EnableBasicAI, v[Temp1 + 3] & ~AgentBits_FLAG_EnableBasicAI, v[Temp1 + 3] | AgentBits_FLAG_EnableBasicAI, v[Temp1 + 3] & ~AgentBits_FLAG_EnableBasicAI][v[Temp1 + 241]] : v[Temp1 + 3]
			
		    }
		    v[2878] += 1
		    
		}
	}
	v[2861..2875] = 0
	v[2875] = 0
}

__fn func_pathfinding_open_Node(){
	// "check"
	v[380] = 0
	Temp10 = v[4582]
	Temp9 = v[4568]
	Temp10 += Temp9
	@loop v[4582] .dst Temp10 {
	    Temp11 = v[4568] + Temp10
	    @if v[Temp11] == var9 {
		v[380] = 1
		Temp11 += 40000
		// "compare cost"
		@if v[Temp11] > v[20] {
		    v[Temp11] = v[20]
		    v[v[4600] + var9 - 1] = v[4590]
		    
		}
		@break
		
	    }
	    
	}

	/*
	@if s[1] .isOn() {
	    @while Temp9 <= Temp10 {
		//opt 28.4.23
		//Temp11 = (Temp9 + Temp10) / 2
		Temp11 = (Temp9 + Temp10) 
		Temp11 /= 2
		@if v[Temp11] == var9 {
		    v[380] = 1
		    Temp11 += 40000
		    // "compare cost"
		    @if v[Temp11] > v[20] {
			v[Temp11] = v[20]
			
		    }
		    @break
		    
		} .else bl {
		    @if v[Temp11] < var9 {
			Temp9 = Temp11 + 1
			
		    } .else bl {
			Temp10 = Temp11 - 1
			
		    }
		    
		}
		
	    }
	    
	    
	}
	*/

	Temp10 = v[4583]
	Temp9 = v[4567]
	Temp10 += Temp9
	@while Temp9 <= Temp10 {
	    //opt 28.4.23
	    //Temp11 = (Temp9 + Temp10) / 2
	    Temp11 = (Temp9 + Temp10) 
	    Temp11 /= 2
	    @if v[Temp11] == var9 {
		v[380] = 1
		@break
		
	    } .else bl {
		@if v[Temp11] < var9 {
		    Temp10 = Temp11 - 1
		    
		} .else bl {
		    Temp9 = Temp11 + 1
		    
		}
		
	    }
	    
	}

	@if v[380] == 0 {
	    v[v[4568] + v[4582]] = var9
	    v[v[4555] + v[4582]] = v[20]
	    v[v[4600] + var9 - 1] = v[4590]
	    v[4582] += 1
	    
	}
}

__fn func_pathfinding_remove_OpenNode(){
	Temp10 = v[4582]
	Temp9 = v[4568]
	Temp10 += Temp9
	@while Temp9 <= Temp10 {
	    //opt 28.4.23
	    //Temp11 = (Temp9 + Temp10) / 2
	    Temp11 = (Temp9 + Temp10) 
	    Temp11 /= 2
	    @if v[Temp11] == var9 {
		//ugh this one seem brutal
		v[0] = v[Temp11..v[4568] + v[4582]] = v[Temp11 + 1..v[4568] + v[4582] + 1]
		v[0] = v[Temp11 + 200..v[4555] + v[4582]] = v[Temp11 + 201..v[4555] + v[4582] + 1]
		v[4582] -= 1
		@break
		
	    } .else bl {
		@if v[Temp11] < var9 {
		    Temp10 = Temp11 - 1
		    
		} .else bl {
		    Temp9 = Temp11 + 1
		    
		}
		
	    }
	    
	}
}

