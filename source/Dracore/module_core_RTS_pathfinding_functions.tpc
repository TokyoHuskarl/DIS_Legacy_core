
// Raycast
__fn func_nodecheck_RayCast $X0 $Y0 $X1 $Y1 {

	// use Bresenham's line algorithm to check line from Point1 to Point2
	// use common vars to caluculate
	defv {
		RC_deltax = __id(TT1)
		RC_deltay = __id(TT2)

		RC_x = __id(TT3)
		RC_y = __id(TT4)
		RC_err = __id(TT5)

		RC_swapx = __id(TT6)
		RC_swapy = __id(TT7)
		RC_err2 = __id(TT8) 
	}

	// RC_deltax = abs($X1 - $X0)
	RC_deltax = ($X1 - $X0)
	RC_deltax = abs(RC_deltax)

	// RC_deltay = abs($Y1 - $Y0)
	RC_deltay = ($Y1 - $Y0)
	RC_deltay = abs(RC_deltay)
	RC_deltay *= -1 // only -(dy) used in this proc, so make RC_deltay = (dy * -1) initially to optimize in RM system
	
	RC_swapx = $X0 < $X1 ? 1 : -1
	RC_swapy = $Y0 < $Y1 ? 1 : -1
	RC_err = RC_deltax + RC_deltay

	RC_x = $X0
	RC_y = $Y0

	// get Start Node Ptr
	defv RC_PF_NodePtr = __id(TT9)
	RC_PF_NodePtr = LEGV_MapNodeAmountX * RC_y
	RC_PF_NodePtr += RC_x
	RC_PF_NodePtr *= Node_Data_Size
	RC_PF_NodePtr += RMconst_Node_Array_Address_Start_MINUS_NODE_MEMSIZE

	@loop bl {
	
		// reach the goal coordinate
		// if the agent can reach there, it doesn't matter whether the goal node is wall or not
		@if RC_x == $X1 {
			@if RC_y == $Y1 {
				reg1 = 0 // no obstacle found, return 0
				@break
			}
		}
		

		/* check node information of the coordinate */
		v[RC_PF_NodePtr].copy mapnode_RefMapX, 3 // Node[2] is movement cost that we need
		@if mapnode_MovementCost >= Node_Obstacle_Threshold {
			reg1 = 1 // return 1
			@break
		}
	

		RC_err2 = RC_err * 2
		
		@if RC_err2 > RC_deltay {
			RC_err += RC_deltay // -(dy)
			RC_x += RC_swapx
			// Node X diff
			RC_PF_NodePtr += RC_swapx * Node_Data_Size
		}

		@if RC_err2 < RC_deltax {
			RC_err += RC_deltax
			RC_y += RC_swapy
			// Node Y diff
			// use reg1 to temp var
			reg1 = RC_swapy * LEGV_MapNodeAmountX
			RC_PF_NodePtr += reg1 * Node_Data_Size
		}
		
	}

}



// maybe movement order itself should be combined in one
__fn func_pathfinding_move(){}

__fn func_pathfinding_move_b(){
	// "移動指示	Center(x.y)=(wheretox,wheretoy)"

	v[2878] = v[1212]
	v[390] = 0
	@if v[2875] >= 1 {
	    // "WPをとおる"
	    v[2863].copy v[2861], 2
	    v[2865].copy v[2863], 2
	    v[2867].copy v[2865], 2
	    v[2869].copy v[2867], 2
	    v[2871].copy v[2869], 2
	    v[2873].copy v[2871], 2
	    // "#Set 移動するX"
	    // "#Set 移動するY"
	    v[2851].copy v[2873], 2
	    
	}

	// experimental - check if the target coordinate is in map or not
	//to deal with the crash bug in 1.162BETA2
	macro_ck_if_given_rel_coord_is_inside_map(v[2851],v[2852])

	// if the coord is inside map...
	@if reg1 != 1 {
		// then start the movementa order
		@loop .inf() {
		    @if v[v[2878]] == 0 {
			// "とぎれた"
			@break
			
		    }
		    // "配列ゲット"
		    Temp1 = v[v[2878]] * 300 
		    Temp1 += 4700
		    Ptr20 = Temp1 + 242
		    v[299] = Temp1 + 41
		    v[298] = Temp1 + 42
		    v[297] = Temp1 + 18
		    Ptr15 = Temp1 + 241
		    v[294] = Temp1 + 55
		    v[629] = Temp1 + 29
		    @if v[v[297]] > 0 {
			// "if you have obj"
			@if v[Ptr15] == 2 { // ATK
			    v[Ptr20] = 2
			    @if `v[Temp1 + 3] & AgentBits_FLAG_PF_walldetection_switch {
			    	v[Temp1 + 34] |= AI_routine_bits_FLAG_1secDelay_PF
			    }

			} .else bl { // OTHERWISE
			    v[Ptr20] = 3 // ForceMovement?
			    @if `v[Temp1 + 3] & AgentBits_FLAG_PF_walldetection_switch {
				v[Temp1 + 34] |= AI_routine_bits_FLAG_1secDelay_PF
			    } .else bl {
				v[Temp1 + 3] &= ~AgentBits_FLAG_NeedWpToReachObj
				
			    }
			    
			}
			@if `!(v[Temp1 + 3] & AgentBits_FLAG_ForcemoveFlag) {
			    @if v[2875] == 0 {
				v[Ptr20] = 2
				
			    }
			    
			}
			
		    }
		    @if s[279] .isOn() {
			v[Ptr20] = 1
			v[Temp1 + 3] &= ~AgentBits_FLAG_NeedWpToReachObj
			@if `v[Temp1 + 3] & AgentBits_FLAG_PF_walldetection_switch {
			    v[Temp1 + 3] |= AgentBits_FLAG_walldetected
			    // 
			    def Pathblock_AND_1secDelay = AI_routine_bits_FLAG_Pathblocked + AI_routine_bits_FLAG_1secDelay_PF
			    v[Temp1 + 34] |= Pathblock_AND_1secDelay
			    
			}
			
		    }
		    @if v[2875] >= 1 {
			v[293] = 2873
			v[293] -= v[2875] * 2
			@loop v[2875] {
			    v[v[293]].copy v[v[299]], 2
			    v[293] += 2
			    v[299] += 2
			    
			}
			
			v[v[293]].copy v[v[299]], 2
			// "#Set 現在目指してるWPと総WP数"
			v[v[294]] = v[2875]
			v[2873] .add v[2855], 2
			
		    } .else bl {
			// "#Set 移動するX"
			v[v[299]] = v[2851]
			// "#Set 移動するY"
			v[v[298]] = v[2852]
			// "#Set 現在目指してるWPと総WP数"
			v[v[294]] = -1
			v[2851] .add v[2855], 2
			
		    }
		    v[293] = Temp1 + 245
		    v[v[293]] = 0
		    // "Make 2nd line"
		    v[390] += 1
		    v[390] %= v[2859]
		    @if v[390] == 0 {
			@if v[2875] >= 1 {
			    v[2853].copy v[2873], 2
			    v[2873] .add v[2857], 2
			    
			} .else bl {
			    v[2853].copy v[2851], 2
			    v[2851] .add v[2857], 2
			    
			}
			v[2851].copy v[2853], 2
			
		    }
		    @if `v[Temp1 + 1] <= 8 {
			v[Temp1 + 3] = v[Temp1 + 241] <= 4 ? [v[Temp1 + 3] | AgentBits_FLAG_EnableBasicAI, v[Temp1 + 3] | AgentBits_FLAG_EnableBasicAI, v[Temp1 + 3] & ~AgentBits_FLAG_EnableBasicAI, v[Temp1 + 3] | AgentBits_FLAG_EnableBasicAI, v[Temp1 + 3] & ~AgentBits_FLAG_EnableBasicAI][v[Temp1 + 241]] : v[Temp1 + 3]
			
		    }
		    v[2878] += 1
		    
		}
	}
	v[2861..2875] = 0
	v[2875] = 0
}

__fn func_pathfinding_open_Node(){
	// "check"
	v[380] = 0
	Temp10 = v[4582]
	Temp9 = v[4568]
	Temp10 += Temp9
	@loop v[4582] .dst Temp10 {
	    Temp11 = v[4568] + Temp10
	    @if v[Temp11] == var9 {
		v[380] = 1
		Temp11 += 40000
		// "compare cost"
		@if v[Temp11] > v[20] {
		    v[Temp11] = v[20]
		    v[v[4600] + var9 - 1] = v[4590]
		    
		}
		@break
		
	    }
	    
	}

	/*
	@if s[1] .isOn() {
	    @while Temp9 <= Temp10 {
		//opt 28.4.23
		//Temp11 = (Temp9 + Temp10) / 2
		Temp11 = (Temp9 + Temp10) 
		Temp11 /= 2
		@if v[Temp11] == var9 {
		    v[380] = 1
		    Temp11 += 40000
		    // "compare cost"
		    @if v[Temp11] > v[20] {
			v[Temp11] = v[20]
			
		    }
		    @break
		    
		} .else bl {
		    @if v[Temp11] < var9 {
			Temp9 = Temp11 + 1
			
		    } .else bl {
			Temp10 = Temp11 - 1
			
		    }
		    
		}
		
	    }
	    
	    
	}
	*/

	Temp10 = v[4583]
	Temp9 = v[4567]
	Temp10 += Temp9
	@while Temp9 <= Temp10 {
	    //opt 28.4.23
	    //Temp11 = (Temp9 + Temp10) / 2
	    Temp11 = (Temp9 + Temp10) 
	    Temp11 /= 2
	    @if v[Temp11] == var9 {
		v[380] = 1
		@break
		
	    } .else bl {
		@if v[Temp11] < var9 {
		    Temp10 = Temp11 - 1
		    
		} .else bl {
		    Temp9 = Temp11 + 1
		    
		}
		
	    }
	    
	}

	@if v[380] == 0 {
	    v[v[4568] + v[4582]] = var9
	    v[v[4555] + v[4582]] = v[20]
	    v[v[4600] + var9 - 1] = v[4590]
	    v[4582] += 1
	    
	}
}

// WHAT THE FUCK IS Temp11?
__fn func_pathfinding_remove_OpenNode(){
	Temp10 = v[4582]
	Temp9 = v[4568]
	Temp10 += Temp9
	// searching TT11 I guess
	@while Temp9 <= Temp10 {
	    Temp11 = (Temp9 + Temp10) 
	    Temp11 /= 2
	    @if v[Temp11] == var9 {
		//ugh this one seem brutal
		v[0] = v[Temp11..v[4568] + v[4582]] = v[Temp11 + 1..v[4568] + v[4582] + 1]
		v[0] = v[Temp11 + 200..v[4555] + v[4582]] = v[Temp11 + 201..v[4555] + v[4582] + 1]
		v[4582] -= 1
		@break
		
	    } .else bl {
		@if v[Temp11] < var9 {
		    Temp10 = Temp11 - 1
		    
		} .else bl {
		    Temp9 = Temp11 + 1
		    
		}
		
	    }
	    
	}
}

