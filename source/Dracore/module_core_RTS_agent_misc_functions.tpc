

//#####################
// Agent Extra Buffer(AEB) funcs
//#####################

// AEB simply just holds agent's additional parameters that are not very frequently called
// maybe making it have complicated function is not good for any term I suppose

// generation function -> @Mission Init in module_core_RTS_mission_general.tpc

// agentid here are expected in a range from 1 to Agents_Limit



// 8.8.2023
// The fact that kern commands of the AEB system have fatal bug in the processes where a MP user cannot touch nor deal with, so all AEAB system is gonna be abandoned.

def AEAB_abandon = {
	__if DIS_EXPERIMENTAL != -1 {
		func_errlog("AEAB function detected, these functions must be removed from DIS source code.")
	}

}
__fn set_AEB_element $agentid $setadd $slot {
	set_picture_pixel($setadd,PicID_AgentExBuffer,$slot,$agentid)
}

// set_AEB_array(int agentid, *var setadd, int startslot, int range)
__fn set_AEB_array $agentid $setadd $startslot $range {
	set_picture_horizontal_line($setadd,PicID_AgentExBuffer,$startslot,$agentid,$range)
}

__fn get_AEB_element $agentid $getadd $slot {
	get_picture_pixel($getadd,PicID_AgentExBuffer,$slot,$agentid)
}

__fn get_AEB_element_wo_ptr $agentid $getadd $slot {
	@pic.getInfo[PicID_AgentExBuffer] .pixel($slot, $agentid, 1, 1) .dst(v[$getadd])
}

__fn get_AEB_array $agentid $getadd $startslot $range {
	get_picture_horizontal_line($getadd,PicID_AgentExBuffer,$startslot,$agentid,$range)
}

__fn init_AEB_array $agentid {
	// fill selected array with 0
	set_picture_horizontal_line(__id(ptr_null), PicID_AgentExBuffer,0,$agentid,AgentExtraBuffer_ArraySize)
}




/**
 * cannot be used for static unit 
 * This function deploys agent data to victim array
 * 
 * @param {int} $agentid - 
 * @param {int} $unitid - 
 */
__fn func_make_agent_transform_into_unit $agentid $unitid {

	// deploy agent data to victim array
	__if $flags & EXTRACT_FLAG_Data_extracted {
		agent_ObjectType.copy victim_ObjectType agent_Basic_Array_size
	}.else bl{
		var1 = $agentid * agent_Basic_Array_size
		var1 += 4701
		v[var1].copy victim_ObjectType agent_Basic_Array_size
	}	
	
	// and?
	
	/*
	  brought unit parameters from database
	*/

	/*
	  adjustment
	*/

	/*
	  rewrite data
	*/

}


__fn func_extract_skill_data_from_agent_slot $agent $skillno $flags {
	__if $flags & EXTRACT_FLAG_Data_extracted {
		reg1 = $skillno * skill_Array_size
		reg1 += __id(agent_AACost)	
		v[reg1].copy skill_ID,skill_Array_size
	}.else bl{
		reg1 = $agent * 300
		reg1 += $skillno * skill_Array_size
		reg1 += 4821
		v[reg1].copy skill_ID,skill_Array_size
	}
}

//reg1 = 0:melee 1:ranged 2:magic... idk 
__fn func_get_AA_usage $agent $flags {
	__if $flags & EXTRACT_FLAG_Data_extracted {
		@if agent_AAType == 0 {//melee
			reg1 = 0
		}.elif agent_AAType == 2 {
			reg1 = 1
		}.elif agent_AAType == 4 {
			reg1 = agent_AA_ARorMR == 0 ? 1 : 2 
		}
		
	}.else bl{
		func_errlog("the function func_get_AA_usage not defined...")
	}
}





__fn agent_static_set_adjustments_for_pic_system {

			@if agent_AAType == 2 {
				func_get_ranged_weapon_velocity(agent_BaseRange_max,1)
					agent_AAvelocity = reg1
			}

			Bool_Refresh_Static_Minimap.on //request refresh minimap static
				v[834..835] = 0
				//MapXY/5 for minimap
				v[600 + AGENT_STATIC_SLOT_MINIMAP_X] = agent_MapX / 5
				v[600 + AGENT_STATIC_SLOT_MINIMAP_Y] = agent_MapY / 5
				@comment "Node check"
				@comment "walls"
				@if agent_UnitType == 107 {


					v[600+AGENT_STATIC_SLOT_MINIMAP_X]=(v[803]+agent_Width/16)/5
						v[600+AGENT_STATIC_SLOT_MINIMAP_Y]=(v[804]+agent_Height/16)/5
						@if `v[603] & 256 {


							v[803].copy var1, 2
								@call .cev 2017
								v[807] = reg1
								v[808..809] = 0
								v[807] = max(v[807], 0)
								v[808] += v[610] * 2 / 32
								v[809] += v[611] * 2 / 32

								/*v[803].copy v[856], 2
									v[856]=(v[856]+v[610]/16)/5
									v[857]=(v[857]+v[611]/16)/5*/

								@loop v[809] .dst v[2064] {
									Ptr6 = v[4564] * (v[807] + v[433] * v[2064]) + v[4569] - 1
										@loop v[808] .dst v[2065] {
											@comment "init"
												Ptr7 = Ptr6 + 3
												@comment "setup"
												@if v[Ptr7] == 0 {
													Ptr7 += 1

												}
											@comment "Cost Set"
												@comment "setup"
												@comment "Cost Set"
												v[Ptr7] -= STATIC_NODE_MOVEMENT_COST_WALL
												@comment "static built"
												v[Ptr6 + 11] |= 32
												@comment "1"
												Ptr6 += v[4564]

										}


								}


						} .else bl {
							v[803].copy var1, 2
								@call .cev 2017
								v[807] = reg1
								v[808..809] = 0
								@if v[610] >= v[611] {
									v[834] = 1

								} .else bl {
									v[835] = 1

								}
							v[807] = max(v[807], 0)
								v[808] += v[610] * 2 / 32
								v[809] += v[611] * 2 / 32
								@loop v[809] .dst v[2064] {
									Ptr6 = v[4564] * (v[807] + v[433] * v[2064]) + v[4569] - 1
										@loop v[808] .dst v[2065] {
											@comment "init"
												Ptr7 = Ptr6 + 3
												@comment "setup"
												@if v[Ptr7] == 0 {
													Ptr7 += 1

												}
											@comment "Cost Set"
												@comment "setup"
												@comment "Cost Set"
												@if s[1] .isOn() {
													Ptr8 = Ptr6 + 1
														Ptr9 = Ptr6 + 2
														@loop 2 .dst v[2067] {
															v[2068] = v[Ptr9] + v[2067]
																@loop 2 .dst v[2066] {
																	v[2069] = v[Ptr8] + v[2066]
																		Temp13 = v[v[1182] + v[2069] - Map_LimitCoordX_min + (v[2068] - Map_LimitCoordY_min) * var_Map_Width] % 100
																		@if Temp13 == 21 {

																		}

																}


														}


												}
											v[Ptr7] += STATIC_NODE_MOVEMENT_COST_WALL
												@comment "static built"
												v[Ptr6 + 11] |= 32
												@comment "1"
												Ptr6 += v[4564]

										}


								}


						}

				} .else bl {
					@if `!between(agent_UnitType, 104, 105) {
						v[607].copy var1, 2
							var1 .sub v[610], 2
							v[11..12] *= 10000
							@call .cev 1999
							v[803] = reg1
							v[804] = reg2
							v[804] += 1
							reg1.copy v[803], 2
							v[803].copy var1, 2
							@call .cev 2017
							v[807] = reg1
							v[808..809] = 1
							v[808] += v[610] * 2 / 32
							v[809] += v[611] * 2 / 32
							@loop v[809] .dst v[2064] {
								Ptr6 = v[4564] * (v[807] + v[433] * v[2064]) + v[4569] - 1
									@loop v[808] .dst v[2065] {
										@comment "init"
											Ptr7 = Ptr6 + 3
											@comment "setup"
											@if v[Ptr7] == 0 {
												Ptr7 += 1

											}
										@comment "Cost Set"
											v[Ptr7] += STATIC_NODE_MOVEMENT_COST
											@comment "static built"
											v[Ptr6 + 11] |= 32
											@comment "1"
											Ptr6 += v[4564]

									}


							}


					} .else bl {
						v[607].copy var1, 2
							var1 .sub v[610], 2
							v[11..12] *= 10000
							@call .cev 1999
							v[803] = reg1
							v[804] = reg2
							v[804] += 1
							reg1.copy v[803], 2
							v[803].copy var1, 2
							@call .cev 2017
							v[807] = reg1
							v[808..809] = 1
							v[808] += v[610] * 2 / 32
							v[809] += v[611] * 2 / 32

					}

				}
			@comment "#minimap"
				v[833] = max(min(muldiv(v[803], 100, v[430]) - 1, v[1277]), 0) + max(min(muldiv(v[804], 100, v[431]) - 1, v[1276]), 0) * v[1277]
				v[834] += v[610] / 7 / v[413] + 1
				v[835] += v[611] / 7 / v[416] + 1
				@comment "####"
				v[602] |= v[602] == 0 ? agent_UnitID : v[602]
				v[841] = 1
				v[603] |= 1048576
				v[899] = 8
				@comment "AVD=-100"
				v[714] = -100
				@comment "CritRedu"
				v[839] = 100
				@comment "Clean up production space"
				v[770..800] = 0
				agent_BaseObjBit |= 64
				agent_BaseObjBit |= 128
				@comment "no_fatigue"
				v[726] |= 2048
				@comment "Big flag"
				agent_BaseObjBit |= 524288
				@comment "No mind"
				agent_BaseObjBit |= BaseObjBit_FLAG_No_mind
				@comment "Halve Ranged"
				agent_BaseObjBit |= 32
				@comment "do not bleed"
				agent_BaseObjBit |= BaseObjBit_FLAG_Immune_to_bleed
				v[844] = 3
				@comment "Design Flaw, temp fix"
				v[820] = agent_BaseObjBit
				@comment "Cost"
				v[31].copy v[851], 4
				@comment "##Team Bonus"
				@if agent_UnitType != 105 {
					@if agent_UnitType != 104 {
						v[711] += 50
							v[705..706] += muldiv(v[706], 2, 10)
							@comment "##Empire"
							@if agent_Culture == 1 {
								v[705..706] += muldiv(v[706], 4, 10)

							}
						@comment "##Sushi"
							@if agent_Culture == 12 {
								v[705..706] -= muldiv(v[706], 12, 100)

							}
						@comment "Artitecture"
							v[705..706] += v[2409 + spawnSet_Team % 3] & 0x40000 ? muldiv(v[706], 20, 100) : 0
							v[711] += v[2409 + spawnSet_Team % 3] & 0x40000 ? 50 : 0

					}

				}

				// sprite pattern set for static agents
				// in legacy design, using action state was used to indicate sprite pattern, this will be abolished
				agent_static_Spritepattern = agent_ActionState > 0 ? agent_ActionState + 2 : 2


}


__fn agent_static_set_adjustments_for_finish_set {
			v[899] = max(1,v[899]) // assure at least one sprite layer

			//cache flag
			v[725] |= 512

			v[607].copy reg1, 2
			reg1 .add v[53], 2
			reg1 .sub v[76], 2
			reg1 .div v[74], 2
			@comment "TT1=MortX  TT2=MortY ビット演算して処理するよ"
			reg1 = (reg1 | reg1 << 8) & 0xFF00FF
			reg1 = (reg1 | reg1 << 4) & 0xF0F0F0F
			reg1 = (reg1 | reg1 << 2) & 0x33333333
			reg1 = (reg1 | reg1 << 1) & 0x55555555
			reg2 = (reg2 | reg2 << 8) & 0xFF00FF
			reg2 = (reg2 | reg2 << 4) & 0xF0F0F0F
			reg2 = (reg2 | reg2 << 2) & 0x33333333
			reg2 = (reg2 | reg2 << 1) & 0x55555555
			@comment "yは1bitシフトで終わり"
			reg2 <<= 1
			@comment "最後にTT1 OR TT2"
			v[609] = reg1 | reg2
			@if `between(agent_UnitType, 104, 105) {
				@comment "Flat Static"
					v[726] |= 1048576

			}
		str3 .asg ""
			str5 .asg t[20034]
			@comment "Load"
			v[1942] = agent_UnitID
			v[1941] = v[4576] + v[1942] - 1
			t[2998] .asg t[v[1941]]
			t[2998] .split "|", t[2999], v[1941]
			str3 .asg t[2999]
			t[2999..3000] .asg ""
			str1 .asg str3



			//save map tile infomation where the Static built
			v[605].copy Temp11, 2
			Temp11 .add v[1061], 2
			Temp11.copy Temp3, 2
			macro_cord_diff(Temp11 Temp12)
			Temp13 = v[v[1182] + Temp11 - Map_LimitCoordX_min + (Temp12 - Map_LimitCoordY_min) * var_Map_Width]
			v[657] = Temp13 / 100000000
			v[640] = Temp13 % 100


}


