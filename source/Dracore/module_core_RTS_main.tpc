
    
#include "./../headers/header_common.tpc"

#include "./module_core_RTS_misc_functions.tpc"
#include "./module_core_RTS_ui_misc_functions.tpc"
#include "./../headers/header_drawing.tpc"
#include "./../headers/header_scripts.tpc"
#include "./../headers/header_ui.tpc"
// #include "./../headers/header_agent.tpc" - included in header_scripts.tpc
#include "./../preset_databases/header_preset_particles.tpc"


def Ptr_worker_on_job_start = 2940 







//this is obsolete shite
__fn macro_HPSPreg $agent $HP_or_SP $amount{
	/* Var1 = Obj 1~
	Var2 = 0/1# HP/MP
	Var3 = Amount*/
	TT2 = $agent * 300 + 4806 + ($HP_or_SP * 2)
	// "Min(HealedHP,MaxHP)"
	v[TT2] = min(v[TT2] + $amount, v[TT2 - 1])
}




#include "./../headers/header_battlesystem.tpc"

//agent_ref_stats()
#include "./module_core_RTS_main_refresh_agents_stats.tpc"

//RTS_MAIN_LAND_AGENT_1f()
#include "./module_core_RTS_main_land_agent_behavior.tpc"



//CEV 1f
cev .id(18), .name("Main:Agent per1f") , .parallel , .cond(Const_Is_RTS_Mode), {   
	@comment "module_core_RTS_main.tpc"

	// reloading system  -> module_core_RTS_control_camera.tpc

	v[522] = v[2501] == 0 ? -v[522] : v[182] // v[522] = v[2501] == 0 ? 0 : v[522] + v[182]
	v[ptr_null].copy v[181],4
	v[191] -= 1

	v[ptr_null].copy v[v[1071]], Const_var_save_all_morton_memories

	// get Map Origin's ref coord
	LEGV_MainMAP_PointOfReferenceX = ev[1].scrx
	LEGV_MainMAP_PointOfReferenceY = ev[1].scry
	LEGV_MapTileOriginX = ev[3].scrx
	LEGV_MapTileOriginY = ev[3].scry

	// "#WalkingSwitchOff"
	__if DIS_EXPERIMENTAL == 0 {
		s[3001..4000].off
	}

	// "Normal Units"
	v[536] = v[4532]
	@while v[v[536]] != 0 {
		RTS_MAIN_LAND_AGENT_1f()
		//"++"
		increment_var(v[536]) // v[536] += 1
		
	}

	// "STATICS"
	v[536] = v[4533]
	@while v[v[536]] != 0 {
	    v[401] = v[v[536]] - 1
	    Temp1 = v[401] * v[1117] 
	    val_add(Temp1,N5001) // Temp1 += 5001
	    v[Temp1].copy agent_AgentType, 300
	    @if `!(agent_AgentBits & 2097152) {
				@if `v[811] & 2 { // there's moving static (vikang ship

						Bool_Refresh_Static_Minimap.on//request refresh static minimap
						// "Get [1-100]"
						// "モートン座標を記録するよ"
						v[607].copy TT1, 2
						TT1 .add v[53], 2
						TT1 .sub v[76], 2
						TT1 .div v[74], 2
						// "TT1=MortX
						//TT2=MortY
						//ビット演算して処理するよ"
						TT1 = (TT1 | TT1 << 8) & 0xFF00FF
						TT1 = (TT1 | TT1 << 4) & 0xF0F0F0F
						TT1 = (TT1 | TT1 << 2) & 0x33333333
						TT1 = (TT1 | TT1 << 1) & 0x55555555
						TT2 = (TT2 | TT2 << 8) & 0xFF00FF
						TT2 = (TT2 | TT2 << 4) & 0xF0F0F0F
						TT2 = (TT2 | TT2 << 2) & 0x33333333
						TT2 = ((TT2 | TT2 << 1) & 0x55555555)<<1
						// "yは1bitシフトで終わり"
						//TT2 <<= 1
						// "最後にTT1 OR TT2"
						v[609] = TT1 | TT2
						
				}
				// "モートン座標を記録しおえたよ 次はリストに登録するよ TT3=カウンター TT2=ポインター"
				TT1 = v[609]
				// "#ルート空間だよ"
				TT2 = v[1067] + v[v[1071]]
				v[TT2] = v[401] + 1
				v[v[1071]] += 1
				// "#第5空間だよ0~1023"
				TT3 = v[4538] + TT1
				v[TT1 * v[1004] + v[4535] + v[TT3]] = v[401] + 1
				v[TT3] += 1
				// "#第四空間だよ 0~255"
				TT1 >>= 2
				TT3 = v[4537] + TT1
				v[TT1 * v[1004] + v[4534] + v[TT3]] = v[401] + 1
				v[TT3] += 1
				// "#第三空間だよ 0~63"
				TT1 >>= 2
				TT3 = v[1074] + TT1
				v[TT1 * v[1004] + v[1070] + v[TT3]] = v[401] + 1
				v[TT3] += 1
				// "#第二空間だよ 0~15"
				TT1 >>= 2
				TT3 = v[1073] + TT1
				v[TT1 * v[1004] + v[1069] + v[TT3]] = v[401] + 1
				v[TT3] += 1
				// "#第一空間だよ 0~3"
				TT1 >>= 2
				TT3 = v[1072] + TT1
				v[TT1 * v[1004] + v[1068] + v[TT3]] = v[401] + 1
				v[TT3] += 1
				// "モートン座標関係はこれで終わり"
				
	    }
	    // "STATIC OBJECT"
	    val_sub(Temp1,N1) // Temp1 -= 1
	    // "Sub Timer"
	    v[680] .sub v[1089], v[1060]
	    // "#"
	    // "WPのずれを一括で修正"
	    v[641] .add v[1021], 2
	    // "座標ずらし"
	    // "#壁衝突チェックパート
	    //#自己x 311
	    //#自己y 312
	    //#保存x*10000 303
	    //#保存y*10000 304"
	    //This part seems needless after once you save the height I guess?
	    v[605].copy Temp11, 2
	    Temp11 .add v[1061], 2
	    Temp11.copy Temp3, 2
		    
	    // "######################Get Terrain and Elevation info"
	    @if `v[811] & 2 { // skip getting tile info unless it's moving static...

		    // "ずれ計算"
		    macro_cord_diff(Temp11 Temp12)
	    
		    Temp13 = v[v[1182] + Temp11 - Map_LimitCoordX_min + (Temp12 - Map_LimitCoordY_min) * var_Map_Width]
		    v[657] = Temp13 / 100000000
		    v[640] = Temp13 % 100
	    }
	    // "######################"
	    Temp3 .add v[612], 2

	    // "ずれ計算"
	    macro_cord_diff(Temp3 Temp4)

	    // "set mapXY"
	    Temp3.copy v[626], 2

	    // "X座標"
	    // "#カメラずらして"
	    val_add(agent_MilPixX,FrameCamDiff_MilX) // v[605] += v[53] * 10000
	    // "Y座標"
	    // "#カメラずらして"
			val_add(agent_MilPixY,FrameCamDiff_MilY) // agent_MilPixY += v[54] * 10000

			/*
	    // "#座標を反映"
	    v[607] = v[605] / 10000
	    // "#座標を反映"
	    v[608] = v[606] / 10000
			*/
			agent_MilPixX.copy agent_RelativeX,2
			v[__id(agent_RelativeX)..__id(agent_RelativeY)] /= 10000

	    // "###################"
	    /* "#############
	    #Set Y Position EV
	    #############"*/
	    //TT4 = Temp1 + 1
	    //TT5 = Temp1 + 7

	    // set absolute coord
	    macro_convert_absolute_coord(agent_RelativeX,agent_AbsoluteX)

	    TT8 = v[401] + 501
	    s[TT8].off

	    agent_AgentBits &= -1073741825//~AgentBits_FLAG_Drawn_in_screen
	    //opt
	    TT10 = Address_agent_inSight_switch_array_head + v[401]
	    @if s[TT10] .isOn() {
	    //@if `s[2001 + v[401]] != 0 {
			// "Walls "
			v[1008].copy TT14, 4
			@if `agent_AgentBits & 16 {
			    TT14 -= 240
			    TT15 += 240
			    TT16 -= 240
			    TT17 += 240
			    
			}
			//Set Obj into Drawing List
			val_sub(TT14,v[610]) // TT14 -= v[610]
			val_add(TT15,v[610]) // TT15 += v[610]
			@if v[607] >= TT14 {
				@if v[607] <= TT15 {
						//TT6 = Temp1 + 8
						//TT7 = Temp1 + 11
				    TT16 -= v[611] + v[882]
				    TT17 += v[611] - v[882]
				    @if v[608] >= TT16 {
					    @if v[608] <= TT17{
								// "#Set OffsetY"
								v[637] = v[608] + v[882]
								// "Will_be_depicted"
								agent_AgentBits |= AgentBits_FLAG_Drawn_in_screen
								s[TT8].on
								// "#"
								// "#描画範囲内であれば保存"
								v[v[1112] + v[184]] = (v[608] + v[611] + v[1011]) * 1000 + v[401]
								v[v[1113] + v[184]] = v[401]
								val_add(v[184],N1) // v[184] += 1
								
					    }
				   }
				}
	    		}
	    }
	    TT1 = Temp1 + 1
	    agent_AgentType.copy v[TT1], 300

	
	    // "++"
	    increment_var(v[536])// v[536] += 1
	    
	}

	// "DEAD BODIES"
	v[536] = v[4531]
	@while v[v[536]] != 0 {
	    v[401] = v[v[536]] - 1
	    // "死体"
	    Temp1 = v[401] * v[1117] 
	    val_add(Temp1,N5000) // Temp1 += 5000
	    func_main_extract_agent_vars()

	    // "慣性"
	    // "座標ずらし"
	    //Ptr20 = Temp1 + 5
	    //Ptr19 = Temp1 + 12
	    //Ptr18 = Temp1 + 7
	    //Ptr17 = 53
	    //Ptr15 = Temp1 + 266
	    //Ptr14 = Temp1 + 265

			// weapon fall
	    @if v[865] < v[866] {
				v[864] += g_perFPS //98000 / 48
				v[861] .add v[863], 2
				val_add(v[867],v[868]) // v[867] += v[868]
				
				val_add(v[865],N1) // v[865] += 1
		
	    }
	    @if v[881] != 0 {
				v[881] = muldiv(v[881], 4, 5)
				v[882] /= 2
				v[879] = divmul(v[879] ,17500,10000) 
	    }

			// shield fall
	    @if v[873] < agent_ProcessObjBit {
				v[872] += g_perFPS //98000 / 48
				v[869] .add v[871], 2
				val_add(v[875],agent_ProcessCamoValue) // v[875] += agent_ProcessCamoValue
				val_add(v[873],N1) // v[873] += 1
		
	    }
			
	    @if v[887] < v[888] {
				v[886] +=  g_perFPS //98000 / 48
				v[883] .add v[885], 2
				val_add(v[887],N1) // v[887] += 1
		
	    } .else bl {
				v[1301].copy v[885], 2

	    }
	    // "#壁衝突チェックパート
	    //#自己x 311
	    //#自己y 312
	    //#保存x*10000 303
	    //#保存y*10000 304"
	    v[605].copy Temp11, 2
	    Temp11 .add v[1061], 2
	    Temp11.copy Temp3, 2

	    //v[311..312] /= 10000
	    // "ずれ計算"
	    //24.4.23
	    macro_cord_diff(Temp11 Temp12)

	    @map.getTerrain .pos Temp11, Temp12 .dst Temp13
	    // "#移動先壁チェック"

	    Temp3 .add v[612], 2
	    // "ずれ計算"
	    macro_cord_diff(Temp3 Temp4)

	    // "X座標"
	    @map.getTerrain .pos Temp3, Temp12 .dst Temp13
	    // "##20以上で壁がある
	    //##壁がなければ速度を足す"
	    
	    //Ptr20 = Temp1 + 5
	    //Ptr19 = Temp1 + 12
	    //Ptr18 = Temp1 + 7
	    //Ptr17 = 53
	    //Ptr15 = Temp1 + 266
	    //Ptr14 = Temp1 + 265

	    // "#減衰"
	    v[612] = muldiv(v[612], 4, 5)
	    v[612] = 500 >= abs(v[612]) ? 0 : v[612]
	    v[605] += Temp13 < 20 ? v[612] : 0
	    // "#カメラずらして"
	    v[605] += FrameCamDiff_MilX
	    // "#座標を反映"
	    v[607] = v[605] / 10000
	    // "Y座標"
	    @map.getTerrain .pos Temp11, Temp4 .dst Temp13
	    //v[297..300] += 1
	    // "##20以上で壁がある
	    //##壁がなければ速度を足す"
	    // "#減衰"
	    v[613] = muldiv(v[613], 4, 5)
	    v[613] = 500 >= abs(v[613]) ? 0 : v[613]
	    v[606] += Temp13 < 20 ? v[613] : 0
	    // "#カメラずらして"
	    v[606] += FrameCamDiff_MilY
	    // "#座標を反映"
	    v[608] = v[606] / 10000
	    // "慣性終わり"
	    // "#############
	    //#Set Y Position EV
	    //#############"

	    // set absolute cord
	    macro_convert_absolute_coord(agent_RelativeX,agent_AbsoluteX)

	    //Set Obj into Drawing List
	    TT8 = v[401] + 501
	    s[TT8].off
	    agent_AgentBits &= -1073741825//~AgentBits_FLAG_Drawn_in_screen
	    TT10 = Address_agent_inSight_switch_array_head + v[401]
	    @if s[TT10] .isOn() {
					//@if `s[2001+v[401]] != 0 {
				@if v[607] >= v[1008] {
					@if v[607] <= v[1009]{
						@if v[608] >= v[1010]{
							@if v[608] <= v[1011]{
										// "#描画範囲内であれば保存"
										// "Will_be_depicted"
										agent_AgentBits |= AgentBits_FLAG_Drawn_in_screen
										s[TT8].on
										// "#"
										v[v[1112] + v[184]] = (agent_AgentType != -9 ? (v[608] + v[611] >> 1 + v[1011] + 500) * 1000 : 9999000) + v[401]
										v[v[1113] + v[184]]=v[401]
										val_add(v[184],N1) // v[184] += 1
							}
						}
					}
				}
	    }
	    func_main_save_agent_vars()
	    
	    // "++"
	    increment_var(v[536]) // v[536] += 1
	    
	}







}



cev .id(17), .name("Main:Agent per2f") , .parallel , .cond(Const_Is_RTS_Mode), {   
	@comment "module_core_RTS_main.tpc"
	// "Normal Units"
	v[536] = v[4532]
	@while v[v[536]] != 0 {
	    v[401] = v[v[536]] - 1
	    Temp1 = v[401] * v[1117] 
	    val_add(Temp1,N5000)// Temp1 += 5000


	    func_main_extract_agent_vars()

	    // "Minions"
	    // "#########################
	    //Shield Flash
	    //#########################"
	    //opt 26.4.23
	    //v[Temp1 + 284] -= v[Temp1 + 284] > 0 ? 1 : 0
	    v[884] -= v[884] > 0 ? 1 : 0
	    // "Flash Effect"
	    @if v[895] >= 4 {
				v[358..360] = 20
				
	    } .else bl {
				// "Can be improved"
				v[ptr_null].copy v[358],3 // v[358..360] = 0
				v[357 + v[895]] = 20
		
	    }
	    v[891] .sub TT18, 3
	    // "Temp... only check R"
	    v[895] = v[891] <= 0 ? 0 : v[895]
	    // "++"
	    func_main_save_agent_vars()
	    increment_var(v[536]) // v[536] += 1

	}

	@wait 0
	@if Is_Paused .isOff() {
	    v[536] = v[4532]
	    @while v[v[536]] != 0 {
				v[401] = v[v[536]] - 1
				Temp1 = v[401] * v[1117] 
				val_add(Temp1,N5000) // Temp1 += 5000


						func_main_extract_agent_vars()

				/* "###############Timers Check###############"*/
				// "#Check if AI timer is <=2"
				@if v[684] <= 2 {
						// "#Unit Behavior Start"
						// "#Out of Breath"
						// "#Hit Timer ==0&&current SP is below 35%&&the unit has fatigue"
						@if `v[682] <= 0 && divmul(v[707], 100, 35) > v[708] && !(v[726] & 2048) {
					v[682] = 48
					// "Sweat Particle"
					@loop v[1017] .dst Temp20 {
							v[244] %= v[1199]
							v[331] = v[244] * 50 
							v[331] += v[1198]
							@if v[v[331]] <= 1 {
						// "まず清掃"
						v[1301].copy v[v[331]], 50
						// "ポインタセット開始"
						// "設定"
						v[v[331]] = 1
						// "500F"
						v[v[331] + 49] = v[682]
						// "Set itself"
						v[v[331] + 3] = 124
						// "Set Parent Obj"
						v[v[331] + 9] = v[401] + 1
						// "普通にアニメ"
						TT1 = v[331] + 6
						v[607].copy v[TT1], 2
						// "仕上げに登録消す"
						v[244] += 1
						@break
						
							}
							v[244] += 1
							
					}
					
					
						}
						// "#Unit Behavior End"
						
				}
				// "#Footstep Sound"
				@if `agent_AgentBits & AgentBits_FLAG_Drawn_in_screen { //s[v[401] + 501] == 1 {
						@if `agent_ActionFlag & ActionFlag_FLAG_Walking { // DIS_EXPERIMENTAL s[v[401] + v[4558]] == 1 {
							// "#Sub timer"
							val_sub(v[886],N2)
							@if v[886] <= 0 {
									TT1 = v[1179] + v[640] + 20 * v[887]
									v[685] = 13
									@if `agent_MoveTypeBIts & MoveTypeBits_Flying {
										@if v[182] < 1 {
											@if v[522] < 32 {
												v[182] += 1
													// "#########################"
													v[472] = divmul(18, 100, v[2216])
													v[473] = rnd(95, 105)
													v[474] = divmul(v[607] + v[1001], v[1281], 50)
													v[329] = rnd(0, 2)
													inputstr .asg "footsteps\fly"
													inputstr .cat v[329]
													TT2 = 510
													// "Strings = t[TT2]"
													@cmd 11550, t[TT2], .args v[472], 3
													// "#########################"

											}

										}
										v[886] = v[868] / 4 
										v[886]+= rnd(7, 11)
										
									} .else bl {
										@if v[182] < 1 {
												@if v[522] < 80 {
											v[182] += 1
											// "#########################"
											v[472] = divmul(20, 100, v[2216])
											v[473] = rnd(95, 105)
											v[474] = divmul(v[607] + v[1001], v[1281], 50)
											v[329] = rnd(0, 6)
											inputstr .asg t[TT1]
											inputstr .cat v[329]
											TT2 = 510
											// "Strings = t[TT2]"
											@cmd 11550, t[TT2], .args v[472], 3
											// "#########################"
											
												}
												
										}
										v[886] = v[868] / 4 
										v[886] += rnd(7, 11)
										// "Is_in_water"
										@if `agent_AgentBits & 4 {
												// "Bubble Particle"
												@loop v[1017] .dst Temp20 {
											v[244] %= v[1199]
											TT11 = v[244] * 50 
											TT11 += v[1198]
											@if v[TT11] <= 1 {
													// "init"
													v[1301].copy v[TT11], 50
													v[TT11] = 1
													// "timer"
													v[TT11 + 49] = 3
													// "Set itself"
													v[TT11 + 3] = 133
													// "set pos"
													TT1 = TT11 + 6
													v[607].copy v[TT1], 2
													v[244] += 1
													@break
													
											}
											v[244] += 1
											
												}
												
												
										} .else bl {
												@if `agent_ProcessObjBit & 512 {
											@loop v[1017] .dst Temp20 {
													v[244] %= v[1199]
													TT11 = v[244] * 50 
													TT11 += v[1198]
													@if v[TT11] <= 1 {
												// "init"
												v[1301].copy v[TT11], 50
												v[TT11] = 1
												// "timer"
												v[TT11 + 49] = 1
												// "Set itself"
												v[TT11 + 3] = 155
												// "Set Dire"
												v[TT11 + 27] = v[Temp1 + 244]
												// "set pos"
												TT1 = TT11 + 6
												v[607].copy v[TT1], 2
												v[244] += 1
												@break
												
													}
													v[244] += 1
													
											}
											
											
												} .else bl {
											// "Is_horse"
											@if TT1 >= 551 {
													@if `agent_AgentBits & 8 {
												// "Leaf Particle"
												@loop v[1017] .dst Temp20 {
														v[244] %= v[1199]
														TT11 = v[244] * 50 
														TT11 += v[1198]
														@if v[TT11] <= 1 {
													// "init"
													v[1301].copy v[TT11], 50
													v[TT11] = 1
													// "timer"
													v[TT11 + 49] = 3
													// "Set itself"
													v[TT11 + 3] = 134
													// "set pos"
													TT1 = TT11 + 6
													v[607].copy v[TT1], 2
													v[244] += 1
													@break
													
														}
														v[244] += 1
														
												}
												
												
													} .else bl {
												@loop v[1017] .dst Temp20 {
														v[244] %= v[1199]
														TT11 = v[244] * 50 
														TT11 += v[1198]
														@if v[TT11] <= 1 {
													// "init"
													v[1301].copy v[TT11], 50
													v[TT11] = 1
													// "timer"
													v[TT11 + 49] = 3
													// "Set itself"
													v[TT11 + 3] = 130
													// "set pos"
													TT1 = TT11 + 6
													v[607].copy v[TT1], 2
													v[244] += 1
													@break
													
														}
														v[244] += 1
														
												}
												
												
													}
													
											} .else bl {
													
											}
											
												}
												
										}
										
									}
									
							}
							
						}
						
				}

				// "++"
				func_main_save_agent_vars()
				v[536] += 1
				
	    }
	    
	    
	}
}

cev .id(16), .name("Main:Agent per3f") , .parallel , .cond(Const_Is_RTS_Mode), {

	@comment "module_core_RTS_main.tpc"
	// "Normal Units"
	v[536] = v[4532]
	@while v[v[536]] != 0 {
	    v[401] = v[v[536]] - 1
	    Temp1 = v[401] * v[1117] 
	    val_add(Temp1,N5000) // Temp1 += 5000
	    func_main_extract_agent_vars()
	    // "Set Dir"
	    @if Is_Paused .isOff() {
				@if `agent_AgentBits & AgentBits_FLAG_DirChange_skip {
						@if `v[726] & 8388608 {
							agent_AgentBits &= -134217729 //~134217728 ~AgentBits_FLAG_DirChange_skip
							
						}
						
				} .else bl {
						// v[844] = (v[845] & 1) ? v[844] : (v[621] >= 0 ? 0 : 1) //[v[621] >= 0 ? 0 : 1, v[844]][(v[845] & 1)]
						v[844] = v[845] & 1 ? v[844] : (v[621] < 0)
				}
				
	    }

	    // "Get terrain's bit where the unit stands on"
	    v[340] = v[4505] + v[640]
	    v[340].deref v[340],1 // v[340] = v[v[340]]
	    /* "###############Camo Check###############"*/
	    val_asg(agent_ProcessCamoValue,v[617]) // agent_ProcessCamoValue = v[617]

	    // Ambush setting

	    // "#Bush"
			// |= cond ? BaseObjBit_FLAG_Ambushing : 0
	    agent_ProcessObjBit |= (v[340] & 4 && v[680] <= 0) // v[340] & 4 && v[680] <= 0 ? agent_ProcessObjBit | 1 : agent_ProcessObjBit

	    // "##big units cannot ambush"
	    // agent_ProcessObjBit = agent_ProcessObjBit & 524288 || v[843] > 3 ? agent_ProcessObjBit & ~1 : agent_ProcessObjBit
	    agent_ProcessObjBit &= ~(agent_ProcessObjBit & BaseObjBit_FLAG_big_unit || v[843] > 3)

	    // "##in melee combat"
	    // agent_ProcessObjBit = v[681] >= 1 ? agent_ProcessObjBit & ~1 : agent_ProcessObjBit
	    agent_ProcessObjBit &= ~(v[681] >= 1)

	    val_asg(v[898],v[880]) // v[898] = v[880]
			

	    @if `agent_ProcessObjBit & 1 {
				v[898] = 40 + v[880]
				agent_ProcessCamoValue += 38000
				TT1 = v[4518] + v[401]
				v[TT1] = 0
		
	    }

	    // "##is fleeing?"
	    agent_ProcessCamoValue += v[860] >= 3 ? 40000 : 0
	    // "###############Camo Check end##############"
	    func_main_save_agent_vars()
	    // "++"
	    increment_var(v[536]) // v[536] += 1

	}

	@wait 0
	// "Even Units"
	v[536] = v[4532]
	@while v[v[536]] != 0 {
	    v[401] = v[v[536]] - 1
	    Temp1 = v[401] * v[1117] 
	    val_add(Temp1,N5000) // Temp1 += 5000

	    Ptr19 = Temp1 + 1
	    v[Ptr19].copy agent_AgentType, 300
			agent_ref_stats()
			func_blink_progress()
	    //@call .cev 2020
	    agent_AgentType.copy v[Ptr19], 300    
	    // "++"
	    val_add(v[536],N2) // v[536] += 2
	    
	}

	@wait 0
	// "Odd Units"
	v[536] = v[4532] + 1
	@while v[v[536]] != 0 {
	    v[401] = v[v[536]] - 1
	    Temp1 = v[401] * v[1117] 
	    val_add(Temp1,N5000) // Temp1 += 5000

	    Ptr19 = Temp1 + 1
	    v[Ptr19].copy agent_AgentType, 300

		agent_ref_stats()
		func_blink_progress()
	    //@call .cev 2020
	    agent_AgentType.copy v[Ptr19], 300    
	    // "++"
	    val_add(v[536],N2) // v[536] += 2
	    
	}

	@wait 0
	@if Is_Paused .isOff() {
	    v[536] = v[4532]
	    @while v[v[536]] != 0 {
				v[401] = v[v[536]] - 1
				Temp1 = v[401] * v[1117] 
				val_add(Temp1,N5000) // Temp1 += 5000
							func_main_extract_agent_vars()
				// "#Reg Timer"
				@if v[699] <= 0 {
						//opt 25.4.23
						//v[0] = v[11..13] = [v[401] + 1, 0, v[Temp1 + 272]]
						//var2=0
						// "#EV RecoverH/M"
						/* "Var1 = Obj 1~	Var2 = 0/1# HP/MP	Var3 = Amount"*/
						//TT2 = Temp1+106
						//TT3 = TT2 - 1
						//var3=Temp1+272
						// "#そのうち処理作る"
						val_add(v[706],v[872]) // v[706] += v[872]
						// "Min(HealedHP,MaxHP)"
						v[706] = min(v[706], v[705])
						// "#EV RecoverH/M end"
						var1 = v[401] + 1
						val_asg(var2,N1)// var2 = 1
						// "#Derp Breathing :DDDDDDD"
						// var3 = divmul(v[707], 100, 35) > v[708] && v[665] & 1024 ? 15 : 10
						var3 = ((v[665] & 1024 && divmul(v[707], 100, 35) > v[708]) << 2) + 10 // ? 14 : 10
						@if var3 == 14 {
					// "Breath Particle"
							@loop v[1017] .dst Temp20 {
									v[244] %= v[1199]
									v[331] = v[244] * 50 
									v[331] += v[1198]
									@if v[v[331]] <= 1 {
										// "まず清掃"
										v[1301].copy v[v[331]], 50
										// "ポインタセット開始"
										// "設定"
										v[v[331]] = 1
										// "500F"
										v[v[331] + 49] = v[95]
										// "Set itself"
										v[v[331] + 3] = 126
										// "Set Parent Obj"
										v[v[331] + 9] = v[401] + 1
										// "普通にアニメ"
										TT1 = v[331] + 6
										v[607].copy v[TT1], 2
										// "Colour"
										v[0] = v[v[331] + 31..v[331] + 38] = [0, 40, 150, 90, 0, 40, 150, 60]
										// "仕上げに登録消す"
										v[244] += 1
										@break
										
									}
									v[244] += 1
									
							}
							
							
						}
						// var3 is recovering number
						var3 = muldiv(var3, v[873], 10)
						// "#EV RecoverH/M"
						val_add(v[708],var3) // v[708] += var3
						// "Min(HealedHP,MaxHP)"
						v[708] = min(v[707], v[708])
						// "#EV RecoverH/M end"
						v[699] = v[95] + 2
						// "kill parthian flag AND kiting flag"
						v[726] &= v[628] <= 0 ? -100663297 : v[726]
						/*
						@if v[628] <= 0 {
							//v[726] &= ~33554432
							//v[726] &= ~67108864
							v[726] &=-100663297
						}
						*/

						// kill Pathfinding 1 sec delay by wall detection
						@if `!(v[634] & AI_routine_bits_FLAG_1secDelay_PF) {
							@if `v[603] & AgentBits_FLAG_PF_walldetection_switch {
								v[634] |= v[634] & AI_routine_bits_FLAG_StuckCheckReady ? AI_routine_bits_FLAG_PATHFINDING : AI_routine_bits_FLAG_StuckCheckReady
								v[634] &= v[634] & AI_routine_bits_FLAG_PATHFINDING ? ~(AI_routine_bits_FLAG_PFcontinue + AI_routine_bits_FLAG_StuckCheckReady) : v[634]
								v[634] &= agent_LeftWPtoChase <= 0 ? ~AI_routine_bits_FLAG_1secDelay_PF : v[634]
								v[603] &= ~AgentBits_FLAG_PF_walldetection_switch

							}.else bl{
								v[634] &= AI_routine_bits_KILL_StuckCheckReady

							}
						}.else bl {
							v[634] &= ~AI_routine_bits_FLAG_1secDelay_PF

						}




						//v[680] = Temp1 + 80 
						//v[680] = v[v[680]]


						@if `s[7] == 1 || s[474] == 1 {
							// "##If Fleeing"
							//v[860] = Temp1 + 260
							@if v[680] < -480 {
									v[860] = 0
									
							} .else bl {
								@if v[860] == 3 {
									@if v[680] < -100 {
										// "roll chance to recover from fleeing state"
										v[860] -= (rnd(0, 99) <= (var2 + v[875] / 5) && v[860] > -1) // ? 1 : 0
										
									}
								}
								
							}
							
						}
						
				}

						func_main_save_agent_vars()

				// "++"
				increment_var(v[536]) // v[536] += 1
				
	    }
	    
	    
	}

}


cev .id(15), .name("Main:Agent per6f") , .parallel , .cond(Const_Is_RTS_Mode), {   
	@comment "module_core_RTS_main.tpc"
	// "STATIC"
	// This process needs complete refactoring.
	v[536] = v[4533]
	@while v[v[536]] != 0 {
	    v[401] = v[v[536]] - 1
	    Temp1 = v[401] * v[1117] 
	    val_add(Temp1,N5000) // Temp1 += 5000
	    func_main_extract_agent_vars()

	    //If Move Type STATIC
	    //@if `(agent_static_Attribution_flag & 2) {
			// Save MapXY/5 for static minimap.
			TT1 = Temp1 + 26
			v[TT1] .copy v[AGENT_STATIC_SLOT_MINIMAP_X], 2
			v[AGENT_STATIC_SLOT_MINIMAP_X..AGENT_STATIC_SLOT_MINIMAP_Y] /= 5
			TT1 = Temp1 + AGENT_STATIC_SLOT_MINIMAP_X
			v[AGENT_STATIC_SLOT_MINIMAP_X].copy v[TT1], 2
	    //}


	    // "########################Process Parameters Setting BEGIN########################"
	    // "#Base Parameters Get"
	    //v[861] = Temp1 + 109
	    agent_BaseAD.copy agent_ProcessAD, 11
	    //v[872] = Temp1 + 131
	    agent_BaseRegHP.copy agent_ProcessHPreg, 2
	    // "#Never get Morale Effect"
	    agent_ProcessObjBit = agent_static_Obj_flag | BaseObjBit_FLAG_No_mind //... is this necessary?
	    agent_ProcessCamoValue = agent_BaseCamoValue
	    // "#Set Process Parameters"
	    TT1 = Temp1 + 261
	    v[861].copy v[TT1], 16 //set.
	    // "########################Process Parameters Setting END########################"
	    //v[841] = Temp1 + 241 needless
	    v[843] = Temp1 + 243
	    // "ＳＴＡＴＩＣタイマー"
	    //agent_AgentBits = Temp1 + 3
	    //v[702] = Temp1 + 102
	    v[370] = (Is_Paused == 0 ? 1 : -1) + (agent_AgentBits & AgentBits_STATIC_FLAG_No_function ? -1 : 1)
	    // "have function? "
	    //v[370] += v[agent_AgentBits] & 1024 ? -1 : 1
	    @if v[370] >= 2 {
		// "AAタイマー"
		@if v[702] == 106 {
		    v[628] = Temp1 + 28
		    @if v[v[628]] > 0 {
					// "まだAAできない"
					@if v[v[843]] != 1 {
							v[719] = Temp1 + 119
							v[v[628]] -= v[v[719]]
							
					}
					
		    } .else bl {
			// "AA可能"
			// "AAクールタイムモーションつきなら解消しておく"
			//v[726] = Temp1 + 126
			v[v[843]] = v[Temp1 + 126] == 1 ? 0 : v[v[843]]
			
		    }
		    
		}
		// "#予約がある"
		//v[770] = Temp1 + 170
		@if v[770] >= 1 {
		    // "MP(生産力)をためようね"
		    TT1 = Temp1 + 108
		    //v[707] = Temp1 + 107
		    //v[740] = Temp1 + 140
		    //v[700] = v[Temp1 + 100]
		    @if `v[205 + v[700]] < min(v[v[4580] + v[700]], v[1080]) || agent_AgentBits & 1 {
			//TT2 = v[2409 + v[251] % 3]
			
			__if DIS_EXPERIMENTAL == -1 { 
				macro_get_agent_MetaTeam_into_var(v[v[536]],TT2) // AEBA
			}.else bl {
				TT2 = v[Const_AgentMetaTeam_begin+v[401]]
			}

			v[TT1] += v[740] * 6
			// "徴用スイッチ"
			v[TT1] += TT2 & 134217728 && !(v[Temp1 + 3] & 1) ? muldiv(v[740], 198, 100) : 0
			// "MP(生産力)がたまった"
			@if v[TT1] >= v[707] {
			    v[TT1] = 0
			   // "生産完了"
			    // "#Tech Flag"

			    //ACHTUNG - save all dealed parameters here once, since it will conflict in spawning functions 
			    
			    v[251] = v[700]
			    v[255] = v[401] + 1
			    v[252] = v[607] + rnd(-6, 6)
			    v[253] = v[608] + v[611] + rnd(-3, 3)
			    @call .cev 46 //spawn ev
			    Temp1 = v[401] * 300 
			    Temp1 += 5000
	    		    func_main_extract_agent_vars()//extract STATIC datas again
			    defv Spawned_Agent_Id_Shift = __id(Temp2) 
			    Spawned_Agent_Id_Shift = reg1 * 300 //use Temp2 as 
			    @if v[822] != 3 {
				v[Spawned_Agent_Id_Shift + 4922] = v[Spawned_Agent_Id_Shift + 4922] == 0 ? v[Temp1 + 222] : v[Spawned_Agent_Id_Shift + 4922]
				
			    }
			    v[Temp1 + 3] &= -2//~1
			    @if reg1 >= 1 {
				// "指定地点まで歩かせる"
				TT1 = Spawned_Agent_Id_Shift + 4741
				// "set reserved target "
				v[371]=0//Flag for trained troop
				@if v[618] >= 1 {
				    // "Worker"
				    @if `v[Spawned_Agent_Id_Shift + 4802] == 9 {
					v[371] |= 1//IT'S WORKER! - flag switch on
				        v[Spawned_Agent_Id_Shift + 4718] = v[618]
					v[Spawned_Agent_Id_Shift + 4942] = 1
					v[Spawned_Agent_Id_Shift + 4941] = v[Spawned_Agent_Id_Shift + 4941] != 4 ? 2 : 4
					}.else bl{
					//Combat troops - check if the reserved target is enemy
				    v[Spawned_Agent_Id_Shift + 4718] =(v[Spawned_Agent_Id_Shift + 4800]%3)==(v[v[618] * 300 +4800]%3) ?0:v[618]
				    }
				    
				}
				//v[607] = Temp1 + 7
				//v[v[607]].copy v[607], 2
				//v[641] = Temp1 + 41
				//v[v[641]].copy v[641], 2
				@if `v[607] == v[641] && v[608] == v[642] {
				    // "指定されてない"
				    v[252] = v[607] + rnd(-3, 3)
				    v[253] = v[608] + v[611] + rnd(-3, 3)
				    v[252] .add v[53], 2
				    v[252].copy v[TT1], 2
				    v[Spawned_Agent_Id_Shift + 4942] = 2
				    
				} .else bl {
				    v[Spawned_Agent_Id_Shift + 4942] = v[371] & 1 ? 2 : 3 //if the unit is worker, then give them loose move order 
				    // "指定されてる"
				    v[641].copy v[TT1], 2

				    def Order_Spawned_agent_Pathfinding = AI_routine_bits_FLAG_PATHFINDING + AI_routine_bits_FLAG_PF2Agent 
				    v[Spawned_Agent_Id_Shift + 4734] |= Order_Spawned_agent_Pathfinding
				    //v[reg1 * 300 + 4734] |= 524288
				    
				}
				
			    }
			    
			}
			
		    }
		    // "research particle"
		    @if `agent_AgentBits & 1 {
			@loop v[1017] .dst Temp20 {
			    v[244] %= v[1199]
			    //v[331] = v[244] * 50
			    v[331] = v[244] * 50 
			    v[331] += v[1198]
			    @if v[v[331]] <= 1 {
				// "まず清掃"
				v[1301].copy v[v[331]], 50
				// "ポインタセット開始"
				// "設定"
				v[v[331]] = 1
				// "500F"
				v[v[331] + 49] = 6
				// "Set itself"
				v[v[331] + 3] = 126
				// "Set Parent Obj"
				v[v[331] + 9] = v[401] + 1
				// "普通にアニメ"
				//v[607] = Temp1 + 7
				v[607].copy var1, 2
				TT1 = v[331] + 6
				var1.copy v[TT1], 2
				// "Colour"
				v[0] = v[v[331] + 31..v[331] + 38] = [180, 129, 0, 90, 180, 129, 0, 60]
				// "仕上げに登録消す"
				v[244] += 1
				@break
				
			    }
			    v[244] += 1
			    
			}
			
			
		    }
		    
		}
		// "#Reg Timer"
		@if v[699] <= 0 {
		    // "HP"
		    var1 = v[401] + 1
		    //var2 = 0
		    var3 = Temp1 + 131
		    var3 = v[var3]
		    //@call .cev 2006
		    macro_HPSPreg(var1 0 var3)
		    @if v[TT2] <= 0 {
			// "Check if it can be rebuilded"
			Ptr10 = 300001 + v[700] * 4 //300001 magic number refers to factional resource
			@if `v[Ptr10] >= v[851] && v[Ptr10 + 1] >= v[852] && v[Ptr10 + 2] >= v[853] && v[Ptr10 + 3] >= v[854] && v[855] > 0 {
			    TT1 = Temp1 + 251//reconstructed!
			    v[Ptr10] .sub v[TT1], 4
			    @call .cev 84
			    v[TT2] = v[TT2 - 1]
			    
			} .else bl {
			    // "Decay"
			    v[299..300] = v[401] + 1
			    Ptr18 = Ptr20 * 300 + 4701
			    @if v[Ptr18] >= 1 {
				v[305..312] = Ptr20 * 300 //killed.
				@call .cev 41
				
			    } .else bl {
				// "Dead Static is not removed from List!?"
				/*@if s[1] .isOn() { DEBUG feature, needless now
				    var1 = Ptr20
				    @call .cev 2150
				    var1 = 734947
				    var2 = 1000
				    @call .cev 2149
				    
				}*/
				
			    }
			    
			}
			
		    }
		    // "SP reg"
		    var1 = v[401] + 1
		    //var2 = 1
		    var3 = v[Temp1 + 132]
		    //@call .cev 2006
		    macro_HPSPreg(var1 1 var3)
		    v[699] = Temp1 + 99
		    v[v[699]] = v[Temp1 + 255] >= 1 ? 88 : 48
		    // "init farm owner"
		    v[Temp1 + 255] = 0
		    // "#Flammable"
		    @if `agent_AgentBits & AgentBits_FLAG_Drawn_in_screen {//s[v[401] + 501] {
			@if `!(agent_AgentBits & 2048) {
			    // "#Hp 66%"
			    @if `divmul(v[Temp1 + 105], 100, 66) > v[Temp1 + 106] {
				@if v[182] <= 0 {
				    @if v[522] <= 24 {
					v[182] += 1
					// "#########################"
					v[471] = 11550
					v[472] = divmul(45, 100, v[2216])
					v[473] = rnd(90, 115)
					v[607] = Temp1 + 7
					v[v[607]].copy v[361], 2
					v[474] = divmul(v[361] + v[1001], v[1281], 50)
					// "#########################"
					inputstr .asg "misc\blazing"
					@cmd v[471], inputstr, .args v[472], 3
					
				    }
				    
				}
				
			    }
			    
			}
			
		    }
		    
		}
		v[699] = Temp1 + 99
		TT1 = v[v[699]]
		// "########################"
		
	    }
	    // "目標位置"
	    v[619] = Temp1 + 19
	    v[620] = Temp1 + 20
	    // "################"
	    /* "Obj指定分岐
	Get18 = 目標ObjID"*/
	    @if `v[Temp1 + 18] >= 1 {
		/* "Obj指定があり、そちらに行きたいとき
	Get18 = 目標ObjID"*/
		Temp4 = v[Temp1 + 18] * 300 + 4701
		@if v[Temp4] >= 1 {
		    // "#指定Objが存在する"
		    Temp4 += 6
		    v[Temp4].copy v[v[619]], 2
		    // "#攻撃"
		    @if v[370] >= 2 {
			// "目標地点にカメラのずれを加算"
			v[v[619]] .add v[53], 2
			/* "Temp4 = 次に動く場所x
	Temp6 = 次に動く場所y"*/
			Temp4 = v[v[619]]
			Ptr20 = Temp1 + 7
			Temp4 -= v[Ptr20]
			Temp9 = Temp4
			Temp4 = pow(Temp4, 2)
			// "#######"
			Temp6 = v[v[620]]
			Ptr20 = Temp1 + 8
			Temp6 -= v[Ptr20]
			Temp10 = Temp6
			Temp6 = pow(Temp6, 2)
			Temp4 += Temp6
			// "Set Object[23]"
			Ptr20 = Temp1 + 23
			v[Ptr20] = sqrt(Temp4, 1000)
			Temp18 = v[Ptr20]
			// "AAレンジ内か否かを見る"
			Ptr15 = Temp1 + 117
			v[Ptr15].copy TT1, 2
			// "自分がMeleeなら([相手の幅]*1000)を引いて考える"
			v[340] = Temp18
			v[340] -= v[v[703]] == 0 ? v[335] : 0
			@if v[340] <= TT1 {
			    @if v[340] >= TT2 {
				v[842] = Temp1 + 242
				v[v[842]] = -1
				v[628] = Temp1 + 28
				// "AAタイマー見る"
				v[v[843]] = v[v[628]] <= 0 ? 1 : v[v[843]]
				/* "#＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
	ここの調節でゲームスピードが決定する
#＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃"*/
				v[v[628]] = v[v[628]] <= 0 ? 4800 / 6 : v[v[628]]
				
			    }
			    
			}
			
		    }
		    
		} .else bl {
		    // "#指定Objが存在しない"
		    v[618] = Temp1 + 18
		    // "#Obj目標を消す"
		    v[v[618]] = 0
		    v[607].copy v[v[619]], 2
		    
		}
		
	    }
	    // "########################Particles"
	    @if `agent_AgentBits & AgentBits_FLAG_Drawn_in_screen {//`s[v[401] + 501] {
		// "#Flammable"
		@if `!(agent_AgentBits & 2048) {
		    // "#Hp 66%"
		    @if `divmul(v[Temp1 + 105], 100, 66) > v[Temp1 + 106] {
			// "Fire Particle"
			@loop v[1017] .dst Temp20 {
			    v[244] %= v[1199]
			    v[331] = v[244] * 50 + v[1198]
			    @if v[v[331]] <= 1 {
				// "まず清掃"
				v[1301].copy v[v[331]], 50
				// "ポインタセット開始"
				// "設定"
				v[v[331]] = 1
				// "500F"
				v[v[331] + 49] = 6
				// "Set itself"
				v[v[331] + 3] = 138
				// "Set Parent Obj"
				v[v[331] + 9] = v[401] + 1
				// "普通にアニメ"
				v[607] = Temp1 + 7
				v[v[607]].copy v[607], 2
				TT1 = v[331] + 6
				v[607].copy v[TT1], 2
				// "仕上げに登録消す"
				v[244] += 1
				@break
				
			    }
			    v[244] += 1
			    
			}
			
			
		    }
		    
		}
		v[701] = Temp1 + 101
		// "#Blacksmith"
		@if v[v[701]] == 15 {
		    @loop v[1017] .dst Temp20 {
			v[244] %= v[1199]
			v[331] = v[244] * 50 
			v[331] += v[1198]
			@if v[v[331]] <= 1 {
			    // "まず清掃"
			    v[1301].copy v[v[331]], 50
			    // "ポインタセット開始"
			    // "設定"
			    v[v[331]] = 1
			    // "500F"
			    v[v[331] + 49] = 6
			    // "Set itself"
			    v[v[331] + 3] = 161
			    // "Set Parent Obj"
			    v[v[331] + 9] = v[401] + 1
			    // "普通にアニメ"
			    v[607] = Temp1 + 7
			    v[v[607]].copy v[607], 2
			    v[608] -= 20
			    TT1 = v[331] + 6
			    v[607].copy v[TT1], 2
			    // "仕上げに登録消す"
			    v[244] += 1
			    @break
			    
			}
			v[244] += 1
			
		    }
		    
		    
		}
		// "#MageAltar"
		@if v[v[701]] == 27 {
		    v[628] = Temp1 + 28
		    @if v[v[628]] >= 48 {
			@if v[v[628]] <= 680 {
			    @loop v[1017] .dst Temp20 {
				v[244] %= v[1199]
				v[331] = v[244] * 50 
				v[331] += v[1198]
				@if v[v[331]] <= 1 {
				    // "まず清掃"
				    v[1301].copy v[v[331]], 50
				    // "ポインタセット開始"
				    // "設定"
				    v[v[331]] = 1
				    // "500F"
				    v[v[331] + 49] = 6
				    // "Set itself"
				    v[v[331] + 3] = 139
				    // "Set Parent Obj"
				    v[v[331] + 9] = v[401] + 1
				    // "普通にアニメ"
				    v[607] = Temp1 + 7
				    v[v[607]].copy v[607], 2
				    v[608] -= 12
				    TT1 = v[331] + 6
				    v[607].copy v[TT1], 2
				    // "仕上げに登録消す"
				    v[244] += 1
				    @break
				    
				}
				v[244] += 1
				
			    }
			    
			    
			}
			
		    }
		    
		}
		// "#mana light"
		@if v[v[701]] == 37 {
		    @loop v[1017] .dst Temp20 {
			v[244] %= v[1199]
			v[331] = v[244] * 50 
			v[331] += v[1198]
			@if v[v[331]] <= 1 {
			    // "まず清掃"
			    v[1301].copy v[v[331]], 50
			    // "ポインタセット開始"
			    // "設定"
			    v[v[331]] = 1
			    // "500F"
			    v[v[331] + 49] = 6
			    // "Set itself"
			    v[v[331] + 3] = 164
			    // "Set Parent Obj"
			    v[v[331] + 9] = v[401] + 1
			    // "普通にアニメ"
			    v[607] = Temp1 + 7
			    v[v[607]].copy v[607], 2
			    v[608] -= 20
			    TT1 = v[331] + 6
			    v[607].copy v[TT1], 2
			    // "仕上げに登録消す"
			    v[244] += 1
			    @break
			    
			}
			v[244] += 1
			
		    }
		    
		    
		}
		
	    }
	    @if v[370] >= 2 {
				/* "########################	PAssive#########################"*/
				@if `v[Temp1 + 223] & 1 {
						@if `v[Temp1 + 94] <= 0 {
					v[824] = v[Temp1 + 224] > v[1186] ? v[Temp1 + 224] : 1899
					@call .cev v[824]
					
						}
						
				}
				// "gate flag"
				@if `agent_AgentBits & 256 {
						// "##############"
						Ptr20 = Temp1 + 5
						Ptr19 = Temp1 + 15
						Ptr18 = Temp1 + 7
						Ptr17 = 53
						Ptr16 = Temp1 + 36
						Ptr15 = Temp1 + 296
						// "Get mapXY"
						Ptr13 = Temp1 + 26
						v[Ptr13].copy Temp11, 2
						// "#Obj衝突チェック試作begin"
						Temp19 = v[401]
						// "##"
						v[333] = Temp1 + 7
						v[334] = Temp1 + 8
						v[335] = Temp1 + 10
						v[336] = Temp1 + 11
						/* "Maybe this is faster
			...Yes, this is far faster, it's confirmed."*/
						// "Morton"
						// "##############"
						v[607] = Temp1 + 7
						v[610] = Temp1 + 10
						v[v[607]].copy var1, 2
						v[11..12] -= 20
						var1 .sub v[v[610]], 2
						/* "#########################
#2002 Crd->Mort V1V2 reg1
##########################"*/
						var1.copy TT1, 2
						TT1 .sub v[76], 2
						TT1 .div v[74], 2
						/* "TT1=MortX
			TT2=MortY
			ビット演算して処理するよ"*/
						TT1 = (TT1 | TT1 << 8) & 0xFF00FF
						TT1 = (TT1 | TT1 << 4) & 0xF0F0F0F
						TT1 = (TT1 | TT1 << 2) & 0x33333333
						TT1 = (TT1 | TT1 << 1) & 0x55555555
						TT2 = (TT2 | TT2 << 8) & 0xFF00FF
						TT2 = (TT2 | TT2 << 4) & 0xF0F0F0F
						TT2 = (TT2 | TT2 << 2) & 0x33333333
						TT2 = ((TT2 | TT2 << 1) & 0x55555555)<<1
						// "yは1bitシフトで終わり"
						//TT2 <<= 1
						// "最後にTT1 OR TT2"
						reg1 = TT1 | TT2
						/* "#########################
#2002 Crd->Mort V1V2 reg1 end
##########################"*/
						TT11 = reg1
						v[v[607]].copy var1, 2
						v[11..12] += 20
						var1 .add v[v[610]], 2
						/* "#########################
#2002 Crd->Mort V1V2 reg1
##########################"*/
						var1.copy TT1, 2
						TT1 .sub v[76], 2
						TT1 .div v[74], 2
						/* "TT1=MortX
			TT2=MortY
			ビット演算して処理するよ"*/
						TT1 = (TT1 | TT1 << 8) & 0xFF00FF
						TT1 = (TT1 | TT1 << 4) & 0xF0F0F0F
						TT1 = (TT1 | TT1 << 2) & 0x33333333
						TT1 = (TT1 | TT1 << 1) & 0x55555555
						TT2 = (TT2 | TT2 << 8) & 0xFF00FF
						TT2 = (TT2 | TT2 << 4) & 0xF0F0F0F
						TT2 = (TT2 | TT2 << 2) & 0x33333333
						TT2 = ((TT2 | TT2 << 1) & 0x55555555)<<1
						// "yは1bitシフトで終わり"
						//TT2 <<= 1
						// "最後にTT1 OR TT2"
						reg1 = TT1 | TT2
						/* "##########################2002 Crd->Mort V1V2 reg1 end##########################"*/
						TT1 = TT11
						TT2 = reg1
						/* "TT1 = upper left morton
			TT2 = bottom right morton
			TT5 = shift num"*/
						TT3 = TT1 ^ TT2
						// "#mask with 11000000"
						// "#mask with 110000"
						// "#mask with 001100"
						// "#mask with 000011"
						TT5 = TT3 & 768 ? 10 : TT3 & 192 ? 8 : TT3 & 48 ? 6 : TT3 & 12 ? 4 : TT3 & 3 ? 2 : 0
						v[609] = TT2 >> TT5
						// "#mask end"
						v[340] = v[4546 - TT5 / 2]
						v[327] = v[v[4552 - TT5 / 2] + v[609]]
						// "##############"
						// "DisciplineCheck"
						v[337] = v[401] * 300 
						v[337] += 5010
						v[v[337]].copy v[337], 2
						v[337..338] += 12
						v[339] = v[609] * v[1004] 
						v[339] += v[340]
						v[700] = v[Const_AgentMetaTeam_begin+v[401]]  //v[Temp1 + 100] % 3
						v[371] = 0
						@loop v[327] .dst TT2 {
					v[203] = v[v[339] + TT2] - 1
					agent_AgentType = v[203] * 300 
					agent_AgentType += 5001
					@if v[agent_AgentType] <= 9 {
							v[324] = v[Const_AgentMetaTeam_begin+v[203]] //v[v[203] * 300 + 5100] % 3
							// "対象のColを見る"
							// "#UnitID==NoColならとめる"
							// "対象のObjIDが自分ならとめる"
							@if v[324] == v[700] {
						// "衝突チェック開始"
						v[320..322] = v[203] * 300
						// "T30=modifier for collision, Statics have bigger col"
						Temp20 .add v[1607], 2
						v[322] += v[1610]
						v[v[322]].copy v[322], 2
						//v[0] = v[320..321] = [v[Temp20] - v[v[333]], v[v[321]] - v[v[334]]]
						Temp20 = v[Temp20] - v[v[333]]
						// "TT1でチェック"
						@if `v[322] + v[337] >= abs(Temp20) {
								v[321] = v[v[321]] - v[v[334]]
								@if `v[323] + v[338] >= abs(v[321]) {
							v[371] = 1
							@break
							
								}
								
						}
						
							}
							
					}
					
						}
						
						// "Locked?"
						@if v[371] == 1 {
							@if `!(agent_AgentBits & 4) {
									@if `!(agent_AgentBits & 8) {
								v[Temp1 + 243] = 1
								v[Temp1 + 3] |= 4
								v[803] = Temp1 + 203
								v[v[803]].copy v[803], 4
								@loop v[806] .dst v[2064] {
										Ptr6 = v[803] - Map_LimitCoordX_min + var_Map_Width * (v[804] - Map_LimitCoordY_min) + var_Map_Width * v[2064] + v[4529]
										Ptr7 = v[803] - Map_LimitCoordX_min + var_Map_Width * (v[804] - Map_LimitCoordY_min) + var_Map_Width * v[2064] + v[1182]
										@loop v[805] .dst v[2065] {
											Temp11 = v[2065] + v[803]
											Temp12 = v[2064] + v[804]
											v[Ptr7] /= 100
											v[Ptr7] *= 100
											v[Ptr7] += 1
											// "#TileFuncPushFlag"
											v[Ptr6] &= -2//~1
											v[286..287] += 1
											
										}
										
										
								}
								
								@if v[182] < 2 {
										@if `agent_AgentBits & AgentBits_FLAG_Drawn_in_screen{ //`s[v[401] + 501] == 1 {
									v[607] = Temp1 + 7
									v[v[607]].copy v[607], 2
									v[182] += 1
									// "#########################"
									v[472] = divmul(70, 100, v[2216])
									v[473] = 100
									v[474] = divmul(v[607] + v[1001], v[1281], 50)
									@cmd 11550, "misc\gate_open", .args v[472], 3
									// "#########################"
									
										}
										
								}
								
									}
									
							}
							
						} .else bl {
					@if `agent_AgentBits & 4 {
							v[Temp1 + 243] = 0
							v[Temp1 + 3] &= -5//~4
							v[803] = Temp1 + 203
							v[v[803]].copy v[803], 4
							@loop v[806] .dst v[2064] {
						Ptr6 = v[803] - Map_LimitCoordX_min + var_Map_Width * (v[804] - Map_LimitCoordY_min) + var_Map_Width * v[2064] + v[4529]
						Ptr7 = v[803] - Map_LimitCoordX_min + var_Map_Width * (v[804] - Map_LimitCoordY_min) + var_Map_Width * v[2064] + v[1182]
						@loop v[805] .dst v[2065] {
								Temp11 = v[2065] + v[803]
								Temp12 = v[2064] + v[804]
								v[Ptr7] /= 100
								v[Ptr7] *= 100
								v[Ptr7] += 21
								// "#TileFuncPushFlag"
								v[Ptr6] |= 1
								v[286..287] += 1
								
						}
						
						
							}
							
							@if v[182] < 2 {
						@if `agent_AgentBits & AgentBits_FLAG_Drawn_in_screen {//s[v[401] + 501] == 1 {
								v[607] = Temp1 + 7
								v[v[607]].copy v[607], 2
								v[182] += 1
								// "#########################"
								v[472] = divmul(70, 100, v[2216])
								v[473] = 100
								v[474] = divmul(v[607] + v[1001], v[1281], 50)
								@cmd 11550, "misc\gate_close", .args v[472], 3
								// "#########################"
								
						}
						
							}
							
					}
					
						}
						
				}
				
	    }
	    // "++"
	    increment_var(v[536])// v[536] += 1
	    
	}

	@wait 0
	// "############"
	v[536] = v[4532]
	@while v[v[536]] != 0 {
	    Temp1 = v[v[536]] * v[1117] 
	    val_add(Temp1,N4700) // Temp1 += 4700
	    func_main_extract_agent_vars()
	    // "colck"
	    @if `agent_AgentBits & AgentBits_Movement_Giveup {
				@if `agent_AgentBits & AgentBits_Endpoint_Collision_Trouble {
						//v[842] = Temp1 + 239
						//v[v[842]] = -1
						agent_MovementOrder = -1
						agent_Direction = (cos(agent_MarchingDirection, 1000, -100) + 200) / 200
						agent_AgentBits &= -129 //~128
						
				}
		
	    } .else bl {
				@if `agent_AgentBits & AgentBits_Endpoint_Collision_Trouble {
						//Ptr14 = Temp1 + 22
						@if `(v[2501] / 6 % (agent_ObjectCollideSkipFrame << 4)) == 0 { // "* 16" -> "<< 4"
							agent_AgentBits |= AgentBits_Movement_Giveup
					
						}
						
				}
				@if `agent_ProcessObjBit & BaseObjBit_FLAG_Discipline {
						agent_AgentBits &= -513//~512
						// shift b1 to b1000000000
						agent_AgentBits |= (agent_InCombatTimer <= 0 && agent_MovementOrder <= 0) << 9 // ? 512 : 0
						
				}
				
	    }


	    // "Agent Effect"
	    v[401] = v[v[536]] - 1
	    @if `agent_AgentBits & AgentBits_FLAG_Drawn_in_screen { //`s[v[401] + 501] ==1 {
				// "Hero Particle"
				@if `agent_ProcessObjBit & 4194304 { //is hero
					func_set_preset_particle_emitter(v[331],
						PROC({
							emitter_ParticleType = 1
							emitter_Timer = 6
							emitter_CallPartFunc = cevid_hero_particle
							emitter_ParentObject = v[401] + 1
							// "普通にアニメ"
							agent_RelativeX.copy emitter_RelativeX, 2
							emitter_RelativeY += 8
						})
					)
				}
				
	    }

	    // "Check flee end "
			// if it's not fleeing anymore, then reset movement order
			agent_MovementOrder = agent_MovementOrder == 11 && (agent_ProcessObjBit & BaseObjBit_FLAG_Fleeing) ? 0 : agent_MovementOrder
			
			/*
			@if agent_MovementOrder == 11 {
				@if `!(agent_ProcessObjBit & 512) {
						agent_MovementOrder = 0
						
				}
				
	    }
			*/

	    //v[827] = Temp1 + 227
	    //v[640] = Temp1 + 40
	    //v[640] = v[v[640]]
	    @if agent_InCombatTimer < v[1178] {
				agent_2hweapon_stain -= agent_2hweapon_stain > 0 ? 1 : 0
				
	    }

	    @if agent_Morale <= -1 { // fleeing
				// if the fleeing agent is not in combat for 1800f, stop it fleeing
				agent_Morale = agent_InCombatTimer <= -1800 ? 0 : agent_Morale 
				/*
				@if agent_InCombatTimer <= -1800 { 
						agent_Morale = 0
						
				}
				*/
			
	    }

	    @if agent_TerrainIDstanding == 22 { // On DeepWater tile..
				agent_ChokeTimer += 5
				// "Choked to death"
				@if agent_ChokeTimer >= 200 {
						//Ptr20 = Ptr19 = v[v[536]]
						v[299..300] = v[v[536]]
						Ptr18 = Ptr20 * 300 
						Ptr18 += 4701
						v[305..312] = Ptr20 * 300
						func_main_save_agent_vars()//save anything before die - is this really necessary?
						@call .cev 41 // call choked to death event
						
				}
				
	    } .else bl {
				agent_ChokeTimer = 0 //reset choke timer
				func_main_save_agent_vars()//save
	    }

	    // "#########################PAssive#########################"
	    // "Passive"
	    
	    Temp1 = v[v[536]] * v[1117] 
	    val_add(Temp1,N4700) // Temp1 += 4700
	    TT1 = Temp1 + 1
	    @if v[TT1] > 0 { //if only the unit isn't choked to death
		    v[694] = Temp1 + 94
		    @if v[v[694]] <= 0 {
					v[401] = v[v[536]] - 1
					v[v[694]] = 100
					@if `v[Temp1 + 223] & 1 {
							v[824] = v[Temp1 + 224] > v[1186] ? v[Temp1 + 224] : 1899
							@call .cev v[824]
							
					}
					agent_ProcessObjBit = Temp1 + 274
					@if `v[agent_ProcessObjBit] & 1048576 {
							// "standard_bearer"
							Ptr19 = v[401] + 1
							@if v[217] < v[4559] {
								v[217] += 1
								@loop v[4559] .dst Temp20 {
										v[216] %= v[4559]
										Temp1 = v[216] * 100
										Temp1 += v[1076]
										Ptr15 = Temp1 + 1
										@if v[Ptr15] == 0 {
									// "Access17 = AttackerObjチェックPtr"
									Ptr17 = Ptr19 * 300
									Ptr17 += 4700
									// "まず清掃"
									v[1301].copy agent_AgentType, 100
									v[1301].copy v[Ptr15], 100
									// "ParentObjセット"
									v[609] = Ptr19
									// "出る場所セット"
									TT1 = Ptr17 + 7
									v[TT1].copy v[605], 2
									v[605..606] *= 10000
									v[TT1].copy v[607], 2
									// "Projectile team"
									TT1 = Ptr17 + 100
									v[618] = v[TT1] == 0 ? 1 : 0
									// "パラメータ等入力begin"
									// "#Pic"
									v[602] = 1
									// "#ProjectileType"
									agent_AgentType = 2
									// "#あたり判定"
									v[610..611] = muldiv(v[Ptr17 + 275], 12, 10)
									// "#威力"
									v[621] = 0
									// "#Timer"
									v[700] = 1
									// "#Effect"
									v[604] = 1231
									// "#ARMRと属性"
									v[622] = -1
									v[623] = 1
									v[628] |= 8
									// "パラメータ等入力end"
									agent_AgentType.copy v[Ptr15], 100
									// "Having no timer passive conflict"
									@if `!(v[Ptr17 + 223] & 1) {
											// "Timer Reset"
											v[Ptr17 + 94] = v[1240] * 5
											
									}
									// "Eff"
									TT1 = v[Ptr19 * 300 + 4922]
									@if TT1 >= 1 {
											TT2 = Ptr19 * 300 
											TT2 += 4925
											v[TT2] = (v[TT2] + 1) % 2
											@if v[TT2] == 0 {
										@if `s[500 + Ptr19] == 1 {
												v[607].copy v[361], 2
												@loop v[1017] .dst Temp20 {
											v[242] %= v[1017]
											Temp1 = v[242] * 100
											Temp1 = Temp1 + v[1018]
											@if v[Temp1] <= 1 {
													v[243] -= v[Temp1] == 1 ? 1 : 0
													v[242] %= v[1017]
													Ptr1 = v[242] * 100
													Ptr1 = Ptr1 + v[1018]
													// "まず清掃"
													v[1301].copy v[Temp1], 100
													// "ポインタセット開始"
													Temp10 = v[242] + v[1220]
													Ptr15 = Temp1 + 99
													// "設定"
													v[Temp1] = 1
													v[Ptr15] = 0
													// "普通にアニメ"
													@pic[Temp10].show {
												"passive_icon\picon_0" .repl 1 TT1
												.pos v[361], v[362] .center
												.scrollWithMap
												.chromakey 1
												.scale 100
												.trans 40
												.rgbs 100, 100, 100, 100
												.mapLayer 5
												.eraseWhenTransfer
												.affectedByFlash
												.affectedByShake
													}
													v[362] -= 36
													@pic[Temp10].move {
												.pos v[361], v[362] .center
												.scale 250
												.trans 100
												.time 21
												.rgbs 100, 100, 100, 100
													}
													// "仕上げに登録消す"
													v[242..243] += 1
													@break
													
											}
											v[242] += 1
											
												}
												
												
										}
										
											}
											
									}
									@break
									
										}
										
								}
								
								v[216] += 1
								
							}
							
					}
					
		    }
		}

	    // "++"
	    increment_var(v[536]) //v[536] += 1
	    
	}

	@wait 0

	//TILE INSTANT FLAG CHECK START

	//shield wall
	def ShieldWall_Cover_SquareSide = 5
	def ShieldWall_Cover_Diff = 2
	//Pike Wall
	def PikeWall_Cover_SquareSide = 5 
	def PikeWall_Cover_Diff = 2

	__fn func_set_tileflag_in_square_range $flag $length $diff $var_rangestart $var_rangeend {
		v[__id($var_rangestart)..__id($var_rangeend)] = $flag //set array for flag
		//Start settting shield covered flag on
		defv STARTPOINTx = __id(TT1)
		defv STARTPOINTy = __id(TT2)
		defv Length_x = __id(TT3)
		defv Length_y = __id(TT4)

		//Try not to be over from map range
		agent_MapX.copy STARTPOINTx,2
		STARTPOINTx.sub Map_LimitCoordX_min,2 
		v[__id(STARTPOINTx)..__id(STARTPOINTy)] -= $diff
		STARTPOINTx = max(STARTPOINTx,0)
		STARTPOINTy = max(STARTPOINTy,0)
		var_Map_Width.copy Length_x,2

		Length_x.sub STARTPOINTx,2
		Length_x = min(Length_x,$length)
		Length_y = min(Length_y,$length)

		//func_devlog("Shield Wall aura STARTs from \TT1,\TT2 - Length \TT3,\TT4 ")
		STARTPOINTx += STARTPOINTy * var_Map_Width
		STARTPOINTx += Const_save_var_TileFlags
		@loop Length_y {
			//func_devlog("Shield Wall aura set to memory adress[\TT1] + \TT3 ")
			v[STARTPOINTx].or $var_rangestart, Length_x //set flag
			STARTPOINTx += var_Map_Width
		}
	}

	// initialize Tile Flags
	v[ptr_null].copy v[Const_save_var_TileFlags], var_allocatedmapsize //you should just kill first 2 flags? or not? - it might be changed later. Idk

	//Land units
	val_asg(v[536],v[4532]) // v[536] = v[4532]
	@while v[v[536]] != 0 {
	    Temp1 = v[v[536]] * v[1117] 
	    val_add(Temp1,N4700) // Temp1 += 4700
	    func_extract_agent_vars(v[v[536]])

			// if it's standing on wall tile, let the tile push the agent
			agent_AgentBits |= agent_TerrainIDstanding > 20 ? AgentBits_FLAG_Pushed_by_terrain : 0

	    // "##############
	    //#Terrain Check#
	    //##############"
			defv StandingTerrainInfoBits = __id(v[340])
	    StandingTerrainInfoBits = v[4505] + v[640]
	    StandingTerrainInfoBits.deref v[340],1 // v[340] = v[v[340]]
	    // "#Reset Terrain Flags"
	    agent_AgentBits &= -1072//~1071 //15 + 32 + 1024
	    //agent_MoveTypeBIts = Temp1 + 38
	    // "##Not Flying"

	    @if `!(agent_MoveTypeBIts & MoveTypeBits_Flying) {
				// "#Water"
				// agent_MoveTypeBIts = b1000000
				agent_AgentBits |= StandingTerrainInfoBits & FLAG_TERRAIN_Water ? (4 + ((~agent_MoveTypeBIts & MoveTypeBits_Amphibious) >> 6)) : 0 // (4 + (agent_MoveTypeBIts & 64 ? 0 : 1)) : 0
				
				// "#Ice"
				agent_AgentBits |= (StandingTerrainInfoBits & FLAG_TERRAIN_Ice) << 1 // |= MoveTypeBits_Roller
				// agent_AgentBits |= StandingTerrainInfoBits & 16 ? 32 : 0
				/*
				@if `StandingTerrainInfoBits & 16 {
						agent_AgentBits |= 32
						
				}
				*/

				// "#Stone Road"
				agent_AgentBits |= (StandingTerrainInfoBits & FLAG_TERRAIN_PavedRoad) >> 5
				// agent_AgentBits |= StandingTerrainInfoBits & 64 ? 2 : 0
				/*
				@if `StandingTerrainInfoBits & 64 {
						agent_AgentBits |= 2
						
				}
				*/

				// "#Forest"
				agent_AgentBits |= (StandingTerrainInfoBits & 8 && agent_MoveTypeBIts & 34) << 3 // ? AgentBits_horse_in_forest : 0

				/*
				@if `StandingTerrainInfoBits & 8 {
						// "##Horse or roller"
						@if `agent_MoveTypeBIts & 34 {
							agent_AgentBits |= AgentBits_horse_in_forest
							
						}
						
				}
				*/

				// "#snow"
				@if `StandingTerrainInfoBits & FLAG_TERRAIN_Snow {
						// "##movetype ice"
						// MoveTypeBits_Snow = b10000
						agent_AgentBits |= (agent_MoveTypeBIts & MoveTypeBits_Snow) >> 3
						/*
						@if `agent_MoveTypeBIts & MoveTypeBits_Snow {
							agent_AgentBits |= 2
					
						}
						*/

						// "##skating"
						agent_AgentBits |= agent_MoveTypeBIts & MoveTypeBits_Skate ? 34 : 0
						
				}
				
				// "#sand"
				@if `StandingTerrainInfoBits & FLAG_TERRAIN_Sand {
					// sand crawler
					// MoveTypeBits_Sand = b10000000
					agent_AgentBits |= (agent_MoveTypeBIts & MoveTypeBits_Sand) >> 6 // |= 2 or 0

				}

				// roller
				agent_AgentBits |= agent_MoveTypeBIts & MoveTypeBits_Roller ? 48 : 0 //32+16

				
	    } .else bl {
				// keep hovering on Water tile
				agent_AgentBits |= StandingTerrainInfoBits & 1 ? 1056 : 0

				
	    }
	    // "###################Terrain Check End###################"
	

	    //Set tile instants begin
		//Use Temp2 as ptr to maptile
		Temp2 = Const_save_var_TileFlags + agent_TileLink
		// v[Temp2] |= v[Temp2] & FLAG_Maptile_Occupied ? FLAG_Maptile_Crowded : FLAG_Maptile_Occupied //set occupied flag
		def CrowdedANDOccupied = 3
		v[Temp2] |= ((v[Temp2] & CrowdedANDOccupied) << 1) | FLAG_Maptile_Occupied // ? FLAG_Maptile_Crowded : FLAG_Maptile_Occupied //set occupied flag
		@if agent_TacticsOrderFlag > 0 {
			@if `agent_TacticsOrderFlag & 6 { //using shieldwall
				@if `!(agent_ProcessObjBit & 67108864) { //can use shield
					defv flag_shieldcovered = __id(TT10)
					defv bool_if_my_tile_is_covered = __id(TempFlag1)

					// get agent MetaTeam
					__if DIS_EXPERIMENTAL == -1 { // AEBA
						macro_get_agent_MetaTeam_into_var(v[v[536]],TT1)
						flag_shieldcovered = FLAG_Maptile_ShieldCoverTeam0 << TT1 //shift Meta Team
					}.else bl {
						TT1 = Const_AgentMetaTeam_begin + v[v[536]] //get meta team - isn't this wrong since MetaTeamArray has element in [0]?
						flag_shieldcovered = FLAG_Maptile_ShieldCoverTeam0 << v[TT1] //shift Meta Team
					}

					bool_if_my_tile_is_covered = v[Temp2] & flag_shieldcovered ? 1 : 0 //Check if agent tile is already covered
					func_set_tileflag_in_square_range(flag_shieldcovered ShieldWall_Cover_SquareSide ShieldWall_Cover_Diff Temp11 Temp15)
					v[Temp2] &= bool_if_my_tile_is_covered & 1 ? v[Temp2] : ~flag_shieldcovered // you must be covered by other unit to get shield covered bonus.
				}

			}.elif `agent_TacticsOrderFlag & 1 { //spear wall 
				defv flag_pikecovered = __id(TT10)
				
				// get agent MetaTeam
				__if DIS_EXPERIMENTAL == -1 {
					macro_get_agent_MetaTeam_into_var(v[v[536]],TT1) // AEBA
					flag_pikecovered = FLAG_Maptile_PikeWallTeam0 << TT1 // shift Meta Team
				}.else bl {
					TT1 = Const_AgentMetaTeam_begin + v[v[536]] // get meta team - isn't this wrong?
					flag_pikecovered = FLAG_Maptile_PikeWallTeam0 << v[TT1] // shift Meta Team
				}

				func_set_tileflag_in_square_range(flag_pikecovered ShieldWall_Cover_SquareSide ShieldWall_Cover_Diff Temp11 Temp13)
			}
		}

	    //Set tile instants end

	    // "++"
	    func_main_save_agent_vars()
	    increment_var(v[536]) // v[536] += 1
	    
	}

	@wait 0
	// "Workers?"
	
	ui_workers_amount.copy ui_workers_amount_save, 5
	v[ptr_null].copy ui_workers_amount,5 // v[2941..2944] = 0
	v[536] = v[4532]
	s[187].off
	@while v[v[536]] != 0 {
	    Temp1 = v[v[536]] * v[1117] 
	    val_add(Temp1,N4700) // Temp1 += 4700
	    Ptr1 = Temp1 + 1 
	    v[Ptr1].copy agent_AgentType, 300

	    @if `agent_AgentBits & AgentBits_FLAG_EnableCivAI { //Worker AI flag is on
				val_add(ui_workers_amount,N1) // count up
				// "Escape time"
				val_sub(agent_InCombatTimer,N4) // agent_InCombatTimer -= 4
				@if agent_TeamID == 0 {
						// check idle workers
						@if agent_worker_JobType == 0 {
							@if agent_ActionState == 0 {
								@if agent_MovementOrder <= 0 {
									s[187].on // there's at least one idle worker unit 
									@if Is_Paused .isOff() { // not pause
										@if `agent_AgentBits & AgentBits_FLAG_Drawn_in_screen { 
											@if `(agent_InCombatTimer + agent_generated_ID) / 4 % 124 == 0 { // 124 = magic number but maybe 48*3
												@if `!(agent_ProcessObjBit & BaseObjBit_FLAG_Immune_to_bleed) { // skeletons won't say anything
													agent_RelativeX.copy v[361], 2
													TT1 = 20422 // quote quickstring
													//Dragon voice
													@if agent_Race == 3 {
															// quotes of dragon workers vary
															TT1 += agent_UnitID == 10 ? 1 : 2
															
													}

													str1 .asg t[TT1] // text that says "I'm idle"
													// Set new particle emitter
													@loop v[1017] .dst Temp20 {
															v[242] %= v[1017]
															v[331] = v[242] * 100
															v[331] = v[331] + v[1018]
															@if v[v[331]] <= 1 {
																v[243] -= v[v[331]] == 1 ? 1 : 0
																v[242] %= v[1017]
																// "まず清掃"
																v[ptr_null].copy v[v[331]], 100
																// "ポインタセット開始"
																Temp10 = v[242] + v[1220]
																Ptr15 = v[331] + 99
																// "設定"
																v[v[331]] = 1
																v[Ptr15] = 0
																// "普通にアニメ"
																v[607].copy v[361], 2
																@pic[Temp10].strpic {
																		str1
																		.pos v[361], v[362] .center
																		.size 0, 0                                                   .scrollWithMap
																		.chromakey 1
																		.scale 100
																		.trans v[1066]
																		.rgbs 100, 100, 100, 100
																		.font Font_UI, 11
																		.spacing 0, 0
																		.skin "" .nobg .noframe .noGradation .noPadding
																		.mapLayer 7
																		.eraseWhenTransfer
																		.affectedByFlash
																		.affectedByShake
																}
																v[362] -= 48
																@pic[Temp10].move {
																		.pos v[361], v[362] .center
																		.scale 100
																		.trans 100
																		.time 45
																		.rgbs 100, 100, 100, 100
																}
																// "仕上げに登録消す"
																v[242..243] += 1
																@break
																
															}
															v[242] += 1
															
													}
													
													
												}
												
											}
											
										}
										
									}
									
								}
								
							}
							
						}.else bl{
							// "Count up worker assignment"
							TT1 = agent_worker_JobType + __id(ui_workers_amount)
							v[TT1] += agent_worker_JobType <= 4 ? 1 : 0
						}
						
				}
		
	    }
	    // "PF reset"
			agent_AI_routine_bits &= (agent_generated_ID + v[2501]) % 420 == 0 ? -4097 : agent_AI_routine_bits

			/*
	    @if `(agent_generated_ID + v[2501]) % 420 == 0 {
				agent_AI_routine_bits &= -4097//~4096
		
	    }
			*/

	    func_main_save_agent_vars()	
	    // "++"
	    increment_var(v[536]) // v[536] += 1
	    
	}

	
	@if `ui_workers_for_food != ui_workers_for_food_save || ui_workers_for_wood != ui_workers_for_wood_save || ui_workers_for_wood != ui_workers_for_stone_save || ui_workers_for_stone != ui_workers_for_gold_save {
	    func_refresh_resource_window()

	    
	}

	@wait 0
	//##############
	// blank place - you can add something if you need
	//##############
	@wait 0
	// "DEAD BODIES"
	v[536] = v[4531]
	@while v[v[536]] != 0 {
	    v[401] = v[v[536]] - 1
	    // "死体"
	    Temp1 = v[401] * v[1117] 
	    val_add(Temp1,N5000) // Temp1 += 5000
	    func_main_extract_agent_vars()
	    val_sub(v[680],N1)// v[680] -= 1
	    @if v[680] <= 0 {
				v[898] += 5
				@if v[898] >= 100 {
						// "#############
						//Search and remove from body list"
						Temp2 = v[4531]
						@doWhile v[Temp2] > 0 {
							@if v[Temp2] == v[v[536]] {
									v[Temp2] = 0
									v[v[4531] + v[1004]] -= 1
									v[v[4531]].sortDescending v[1004]
									agent_AgentType = 0
									@break
									
							}
							increment_var(Temp2) // Temp2 += 1
							
						}
						
						var1 = v[401] + 1
						@call .cev 2152
						
				}
				
	    }
	  
	    // "++"
	    func_main_save_agent_vars()
	    increment_var(v[536]) // v[536] += 1
	    
	}

	@wait 0
}

cev .id(2020), .name("Main:Statsets_temp") , {
@comment "module_core_RTS_main.tpc"
	agent_ref_stats()
}

#include "./module_core_RTS_main_projectiles.tpc"
cev .id(21), .name("Main:Projectiles Manager") , .parallel , .cond(Const_Is_RTS_Mode), {
	MAIN_CEV_RTS_PROJECTILE_MANAGER()
}

// Effect Managers
// cevs
#include "./module_core_RTS_main_effects.tpc"
cev .id(22), .name("Main:Normal Effect") , .parallel , .cond(Const_Is_RTS_Mode), {   
	MAIN_CEV_RTS_NORMAL_EFFECT_MANAGER()
}


cev .id(23), .name("Main:Particle Effect") , .parallel , .cond(Const_Is_RTS_Mode), {   
	MAIN_CEV_RTS_PARTICLE_MANAGER()
}


cev .id(24), .name("Main:Gib Effect") , .parallel , .cond(Const_Is_RTS_Mode), {   
	MAIN_CEV_RTS_GIB_MANAGER()
}

// Agent Collision Check
#include "./module_core_RTS_main_collision.tpc"
cev .id(68),.name("Main:Agents Collision"),.parallel , .cond(Const_Is_RTS_Mode), {
	MAIN_CEV_RTS_COLLISION_MANAGER()
}

// #include "./module_core_RTS_main_Frame_Count.tpc" -> module_core_RTS_misc_functions.tpc
cev .id(71), .name("Main:Frame Count") , .parallel , .cond(Const_Is_RTS_Mode), {
	MAIN_CEV_RTS_FRAME_COUNT()
}

// legacy macro cevs
cev .id(2006), .name("RecoverH/M v1v2v3"),{
	macro_HPSPreg(var1 var2 var3)
}

cev .id(2152), .name("miscfunc:remove dead agent pic"), {
	func_remove_dead_agent_picture(var1)
}

//cev 2006
__fn func_main_extract_agent_vars {
	    Ptr1 = Temp1 + 1
	    v[Ptr1].copy agent_AgentType, 300

}

__fn func_main_save_agent_vars {
	    agent_AgentType.copy v[Ptr1], 300
}


__fn func_blink_set {

	@if Is_Paused .isOff()  {
		@if `!(agent_AddMotionBits & 448) {
			//blink flag?
			TT1 = v[604] + v[2500] 
			agent_AddMotionBits |= ((TT1 % 200) == 0) << 6 // ? 64 : 0
		}
	}

}

__fn func_blink_progress {
	@if Is_Paused .isOff()  { // not pause
		@if `agent_AddMotionBits & 448 {
			agent_AddMotionBits = agent_AddMotionBits & 256 ? agent_AddMotionBits & -449 : (agent_AddMotionBits & 128 ? agent_AddMotionBits | 256 : (agent_AddMotionBits & 64 ? agent_AddMotionBits | 128 : agent_AddMotionBits)) //256+128->384 +64 ->448 then ~448 -> -449
		}
	}
}
