// actual functions for scale script commands of DIS:Legacy here 
// it's bit weird since header/header_rmsh_scalescript.tpc refers this meanwhile this is in /module/ Directory


def {
	CTYP_MAP = 1
	CTYP_SND = 2
	CTYP_MISSION = 3
	CTYP_GAME = 4
	CTYP_AGENT = 5
	CTYP_PLAYER = 6
	CTYP_GROUP = 7
	
	CTYP_END
}

deft {
	str_link_Cmd_map = 771
	str_link_Cmd_snd
	str_link_Cmd_mission
	str_link_Cmd_game
	str_link_Cmd_agent
	str_link_Cmd_player
	str_link_Cmd_group

}



// Package Tree - only for calling Cmd.obj.method on RPG_RT.exe, you need init process for each of Cmd Packages before you use this function. 
__fn DIS_Cmd_callPackageTree $counter $CmdStr {

	// Split given Str before calling Package
	macro_demiliterset
	t[$CmdStr] .split($delimiter, SS_CmdObjType, SSnargs)

	// check which object is called by js
	SS_CmdObjType.toNum TT1

	DIS_Cmd_PackTree(TT1,SScmd_Mode_Exec,SScmdDynCounter,0,0)

}


// ---------------------------------------------
// Scale Script Command Package Tree
// ---------------------------------------------




// attention to that linkstr cmd containers of each of the packages are fixed for DIS project. 
__fn DIS_Cmd_PackTree $chosenobj $md $counter $given_v_or_str $flags {

	@if $chosenobj == CTYP_MAP { // Cmd.map
		DIS_Cmd_map(str_link_Cmd_map,$md,$counter,$given_v_or_str,$flags)

	}.elif $chosenobj == CTYP_SND { // Cmd.snd
		DIS_Cmd_snd(str_link_Cmd_snd,$md,$counter,$given_v_or_str,$flags)

	}.elif $chosenobj == CTYP_MISSION { // Cmd.mission
		DIS_Cmd_mission(str_link_Cmd_mission,$md,$counter,$given_v_or_str,$flags)

	}.elif $chosenobj == CTYP_GAME { // Cmd.game
		DIS_Cmd_game(str_link_Cmd_game,$md,$counter,$given_v_or_str,$flags)

	}.elif $chosenobj == CTYP_AGENT { // Cmd.agent
		DIS_Cmd_agent(str_link_Cmd_agent,$md,$counter,$given_v_or_str,$flags)

	}.elif $chosenobj == CTYP_PLAYER { // Cmd.player
		DIS_Cmd_player(str_link_Cmd_player,$md,$counter,$given_v_or_str,$flags)

	}.elif $chosenobj == CTYP_GROUP { // Cmd.player
		DIS_Cmd_group(str_link_Cmd_group,$md,$counter,$given_v_or_str,$flags)
	}

}


// ---------------------------------------------
// Scale Script Command Packages
// ---------------------------------------------


__fn DIS_Cmd_map $LINKstr $md $counter $given_v_or_str $flags {
	SScmdPackage_Build("mp",$LINKstr, $md, $counter, $given_v_or_str, $flags, {
		DIS_map_methods($LINKstr $md $counter $given_v_or_str $flags)
	})
}

__fn DIS_Cmd_snd $LINKstr $md $counter $given_v_or_str $flags {
	SScmdPackage_Build("sn",$LINKstr, $md, $counter, $given_v_or_str, $flags, {
		DIS_snd_methods($LINKstr $md $counter $given_v_or_str $flags)
	})
}

__fn DIS_Cmd_mission $LINKstr $md $counter $given_v_or_str $flags {
	SScmdPackage_Build("mi",$LINKstr, $md, $counter, $given_v_or_str, $flags, {
		DIS_mission_methods($LINKstr $md $counter $given_v_or_str $flags)
	})
}

__fn DIS_Cmd_game $LINKstr $md $counter $given_v_or_str $flags {
	SScmdPackage_Build("ga",$LINKstr, $md, $counter, $given_v_or_str, $flags, {
		DIS_game_methods($LINKstr $md $counter $given_v_or_str $flags)
	})
}

__fn DIS_Cmd_agent $LINKstr $md $counter $given_v_or_str $flags {
	SScmdPackage_Build("ag",$LINKstr, $md, $counter, $given_v_or_str, $flags, {
		DIS_agent_methods($LINKstr $md $counter $given_v_or_str $flags)
	})
}

__fn DIS_Cmd_player $LINKstr $md $counter $given_v_or_str $flags {
	SScmdPackage_Build("pl",$LINKstr, $md, $counter, $given_v_or_str, $flags, {
		DIS_player_methods($LINKstr $md $counter $given_v_or_str $flags)
	})
}

__fn DIS_Cmd_group $LINKstr $md $counter $given_v_or_str $flags {
	SScmdPackage_Build("gr",$LINKstr, $md, $counter, $given_v_or_str, $flags, {
		DIS_group_methods($LINKstr $md $counter $given_v_or_str $flags)
	})
}


// ---------------------------------------------
// Scale Script Command libraries
// ---------------------------------------------


// Cmd.map
__fn DIS_map_methods $LINKstr $md $i $given_v_or_str $flags {
	SScmdLib_Build("map", $LINKstr, $md, $i, $given_v_or_str,$flags, [

		// let javascript interpreter execute what is written in file
		{NsCmd($LINKstr, $md, $i, "spnAg",{cmd_spawn_agent(SSargs0,SSargs1,SSargs2,SSargs3,SSargs4,SSargs5,SSargs6)})}, // map.spawnAgent
		{NsCmd($LINKstr, $md, $i, "spnSt",{cmd_spawnStatic(SSargs0,SSargs1,SSargs2,SSargs3,SSargs4)})}, // map.spawnStatic
		{NsCmd($LINKstr, $md, $i, "spawnPalisade",{cmd_spawnPalisade(SSargs0,SSargs1,SSargs2,SSargs3,SSargs4)})}, // spawnPalisade
		{NsCmd($LINKstr, $md, $i, "spawnWall",{cmd_spawnWall(SSargs0,SSargs1,SSargs2,SSargs3,SSargs4)})}, // spawnWall
		

	])
}

// Cmd.snd
__fn DIS_snd_methods $LINKstr $md $i $given_v_or_str $flags {
	SScmdLib_Build("snd", $LINKstr, $md, $i, $given_v_or_str,$flags, [

		// let javascript interpreter execute what is written in file
		{NsCmd($LINKstr, $md, $i, "pGSE",{cmd_play_global_sound(SSargs0,SSargs1,SSargs2,SSargs3)})}, // snd.playGlobalSE
		{NsCmd($LINKstr, $md, $i, "pBGM",{cmd_play_global_music(SSargs0,SSargs1,SSargs2,SSargs3)})}, // snd.playBGM
		

	])
}

// Cmd.mission
__fn DIS_mission_methods $LINKstr $md $i $given_v_or_str $flags {
	SScmdLib_Build("msn", $LINKstr, $md, $i, $given_v_or_str,$flags, [

		//let javascript interpreter execute what is written in file
		{NsCmd($LINKstr, $md, $i, "endGame",{cmd_player_prepare_endgame(0,SSargs0)})}, // victory or defeat

	])
}

__fn DIS_game_methods $LINKstr $md $i $given_v_or_str $flags {
	SScmdLib_Build("game", $LINKstr, $md, $i, $given_v_or_str,$flags, [

		//let javascript interpreter execute what is written in file
		{NsCmd($LINKstr, $md, $i, "exec",{execute_js(SSargs0)})}, // <- NsLib_js
		{NsCmd($LINKstr, $md, $i, "wait",{@wait (SSargs0)})},
		{NsCmd($LINKstr, $md, $i, "eval",{@js .run SSargs0})},
		{NsCmd($LINKstr, $md, $i, "gotoRMmap",{
			t2v(SSargs0,var1)
			t2v(SSargs1,var2)
			t2v(SSargs2,var3)
			@map[var1].setPlayerPos .pos var2, var3
		})},
		{NsCmd($LINKstr, $md, $i, "msg",{func_show_msg(SSargs0)})},

		

	])
}

__fn DIS_agent_methods $LINKstr $md $i $given_v_or_str $flags {
	SScmdLib_Build("ag", $LINKstr, $md, $i, $given_v_or_str,$flags, [

		//let javascript interpreter execute what is written in file
		{NsCmd($LINKstr, $md, $i, "setName",{
			execute_js(SSargs0)
			})}, // uncinoketafs!!!!IT'S OVER!!!!!!!!

	])
}

__fn DIS_player_methods $LINKstr $md $i $given_v_or_str $flags {
	SScmdLib_Build("plyr", $LINKstr, $md, $i, $given_v_or_str,$flags, [

		//let javascript interpreter execute what is written in file
		{NsCmd($LINKstr, $md, $i, "rvMap",{cmd_reveal_map()})}, // revealMap
		{NsCmd($LINKstr, $md, $i, "mvCam",{cmd_player_change_view(SSargs0,SSargs1,SSargs2)})}, // moveCamera 
		{NsCmd($LINKstr, $md, $i, "tgPaus",{
			@if SSargs0.eq "1" {s[2].on}.else bl{s[2].off}})
		}, // togglePause
		{NsCmd($LINKstr, $md, $i, "giveRs",{cmd_team_give_resource(SSargs0,SSargs1,SSargs2)})}, // Rs 
		{NsCmd($LINKstr, $md, $i, "giveTech",{cmd_team_give_tech_flag(SSargs0,SSargs1,SSargs2)})}, // js incomplete 


	])
}

__fn DIS_group_methods $LINKstr $md $i $given_v_or_str $flags {
	SScmdLib_Build("grp", $LINKstr, $md, $i, $given_v_or_str,$flags, [

		//let javascript interpreter execute what is written in file
		{NsCmd($LINKstr, $md, $i, "endGamefsafsa",{cmd_player_prepare_endgame(0,SSargs0)})},

	])
}

// ---------------------------------------------
// DIS command functions 
// ---------------------------------------------

//all args of functions below are string type since these commands called via SS command

//##########################
//fundamental system commands
//##########################

// "cmd_play_global_sound(soundfilename,v1,v2,v3)"
// no reg
__fn cmd_play_global_sound $filename $volume $tempo $balance {
    /*var1 = $volume
    var2 = $tempo
    var3 = $balance*/
		t2v($volume,var1)
		t2v($tempo,var2)
		t2v($balance,var3)
    @cmd 11550, $filename, .args var1, 3
    
}

// "#play_global_music(soundfilename,v1,v2,v3)"
// no reg
__fn cmd_play_global_music $filename $volume $tempo $balance {
		t2v($volume,var1)
		t2v($tempo,var2)
		t2v($balance,var3)
    var1 = divmul(var1, 100, LEGV_Global_BGM_Volume)
    @bgm.play $filename .opt 0, var1, $tempo, $balance
    Current_BGMFile .asg $filename
}



//##########################
//spawn commands
//##########################


//


// spawn_Unit(var TroopID,var TileX,var TileY,var TeamID,var CohortID,bool Direction,var Stance)
__fn cmd_spawn_agent $troop_id $TileX $TileY $TeamID $CohortID $Dir $Stance {
	t[__id($troop_id)] .toNum spawnSet_TroopID
	t[__id($TileX)] .toNum TT1
	t[__id($TileY)] .toNum TT2
	t[__id($TeamID)] .toNum spawnSet_Team
	t[__id($CohortID)] .toNum spawnSet_Cohort
	//lmao retarded
	bool_Gen_CohortSet.off
	@if spawnSet_Cohort >= 1 {
		bool_Gen_CohortSet.on
	}
	t[__id($Dir)] .toNum spawnSet_Direction
	t[__id($Stance)] .toNum spawnSet_Stance
	//@call .cev 2001
	macro_convert_maptileXY_into_relativeXY(TT1,TT2,spawnSet_x,spawnSet_y)
	//reg2.copy spawnSet_x, 2

	bool_SpawnSystemLegacy.on
	//call fn
	@call .cev 300

	@if spawnSet_Team == 0 {
		//Was?
		@if bool_Gen_CohortSet .isOn() {
		    @call .cev 1906 // -> cohort_general.tpc
		    
		}

	}

}

// koreha hidoi
__fn cmd_spawnStatic $staticID $x $y $team $cohort {
	t[__id($staticID)] .toNum spawnSet_TroopID
	spawnSet_TroopID += 800
	s[177..180].off
	s[151].on
	@call .cev spawnSet_TroopID
	s[151].off
	@if s[179] .isOn() {
		t[__id($x)] .toNum TT11
		t[__id($y)] .toNum TT12
		TT11.copy TT13, 2
		TT11.copy TT1, 2
		TT11 += Map_LimitCoordX_min % 2
		TT12 += Map_LimitCoordY_min % 2
		TT13 += Map_LimitCoordX_min % 2
		TT14 += Map_LimitCoordY_min % 2
		v[351..354] /= 2
		v[351..354] *= 2
		TT15 = (TT11 + TT13 + Map_LimitCoordX_min % 2) / 2
		TT16 = (TT12 + TT14 + Map_LimitCoordY_min % 2) / 2
		@call .cev 2001
		reg2.copy spawnSet_x, 2
		TT13.copy TT1, 2
		@call .cev 2001
		// "############"
		v[11..12] = 0
		var1 .add TT11, 2
		var1 .sub TT13, 2
		v[11..12] *= 16
		@if var1 == var2 {
				var1 *= 2
				var2 *= 2
				
		} .else bl {
				@if var1 > var2 {
			var1 *= 2
			
				} .else bl {
			var2 *= 2
			
				}
				
		}
		var1 = abs(var1)
		var2 = abs(var2)
		v[11..12] += 16
		v[11..12] += 16
		// "############"
		TT15.copy TT1, 2
		@call .cev 2001
		reg2 += 8 - 16 * (Map_LimitCoordX_min % 2)
		reg3 += 8 - 16 * (Map_LimitCoordY_min % 2)
		@if s[177] .isOn() {
				reg2 -= 16
				
		}
		@if s[178] .isOn() {
				reg3 -= 16
				
		}
		reg2.copy spawnSet_x, 2
		t[__id($team)] .toNum spawnSet_Team
		t[__id($cohort)] .toNum spawnSet_Cohort
		s[177..180].off
	
	} .else bl {
		t[__id($x)] .toNum TT1
		t[__id($y)] .toNum TT2
		@call .cev 2001
		reg3 += 8
		reg2.copy spawnSet_x, 2
		t[__id($team)] .toNum spawnSet_Team
		t[__id($cohort)] .toNum spawnSet_Cohort
		
		}
	t[__id($staticID)] .toNum spawnSet_TroopID
	spawnSet_TroopID += 800
	@call .cev spawnSet_TroopID
		
}

__fn cmd_spawnPalisade $begX $begY $endX $endY $team {
	generateWall_preparation($begX,$begY,$endX,$endY,$team)
	@call .cev 835
	
}
__fn cmd_spawnWall $begX $begY $endX $endY $team {
	generateWall_preparation($begX,$begY,$endX,$endY,$team)
	@call .cev 834
	
}

//##########################
//map and sight system functions
//##########################


//cmd_reveal_map()
// just reveal map, no reg 
__fn cmd_reveal_map { // ko koreha hidoi
	//v[562447..572446] ^= 2
	v[LEGV_Ptr2FoW_FlagsArray..LEGV_Ptr2FoW_FlagsArray + 999] ^= 2 //?
	LEGS_MapPreRevealed.on //?
}

//cmd_map_randomise_height_legacy(int xmin,int ymin,int xmax,int ymax,int Tryamount)
// shitty pseudo randomising of map elevaion
__fn cmd_map_randomise_height_legacy $tileXmin $tileYmin $tileXmax $tileYmax $amount {
	@loop $amount {
	    var1 = $tileXmin
	    var2 = $tileYmin
	    var3 = $tileXmax
	    var4 = $tileYmax
	    var1 = rnd(var1, var3)
	    var2 = rnd(var2, var4)
	    var3 = var1 + rnd(12, 18)
	    var4 = var2 + rnd(10, 16)
	    @call .cev 1802
	}
}




//##########################
//Dialogs and messages
//##########################
__fn cmd_show_radio_dialog {

}

//##########################
// AI commands
//##########################




//##########################
// Team commands
//##########################


// ACHTUNG!
// You obviously have to clean up this function
// reg1 = schwerepunktX reg2 = schwerepunktY
__fn cmd_team_get_schwerepunkt $teamID {

	v[2881] = $teamID
	v[2806..2808] = 0
	reg3 = 0
	@loop v[1012] .dst Temp1 {
	    //@comment "Check Player Team List"
	    //@comment "Check AllyTeam List"
	    v[2821] = Temp1 + v[1145 + v[2881] % 3]
	    @if v[v[2821]] >= 1 {
		v[2822] = v[v[2821]] * 300
		v[2822] += 4701
		@if v[v[2822]] <= 9 {
		    @if `v[v[2822] + 99] == v[2881] {
			var1 = v[v[2821]]
			@call .cev 2009
			@if reg1 >= 1 {
			    reg3 += 1
			    
			}
			v[2808] += reg1
			v[v[2822]].copy v[601], 9
			v[607..608] *= reg1
			v[2806] .add v[607], 2
			
		    }
		    
		}
		
	    } .else bl {
		@break
		
	    }
	}
	
	v[2812 + v[2881] % 3] = v[2808]
	v[2806..2807] /= v[2808]
	v[2806].copy v[2853], 2
	v[2806].copy reg1, 2

}

__fn cmd_team_set_pop_limit $teamID $limit {
	v[LEGV_Ptr2PopLimitArray + $teamID] = $limit

}

//cmd_team_set_faction
__fn cmd_team_set_faction $teamID $factionID {
	v[Const_Team_Address_FactionID_Array_Head + $teamID] = $factionID

}


//cmd_team_give_resource
// reg1 = resource amount after this cmd
// reg2 = ptr to the resource indicated in this cmd
__fn cmd_team_give_resource {
	t2v(SSargs0,var1)
	t2v(SSargs1,var2)
	t2v(SSargs2,var3)
	var1 = max(var1, 0)
	var1 = min(var1, 4)
	reg2 = LEGV_Team_Address_Resource_Array_Start + min(var2, 4) + Team_Variables_Array_Size * var1
	reg1 = max(v[reg2] + var2, 0)
	v[reg2] = reg1

}

//cmd
def {
	cmd_FLAG_Use_hex_argv = 0x10

}

__fn cmd_team_give_tech_flag $teamID $tech_group $tech_flag {
	t2v(SSargs0,var1) // teamID
	t2v(SSargs1,var2) // tech slot
	t2v(SSargs2,var3) // this must be hex
	
	// this might seem retarded kek
	var1 = max(var1, 0)
	var1 = min(var1, 3)
	var2 = max(var2, 1)
	var2 = min(var2, 3)
	var2 -= 1

	v[Const_Team_Address_Tech_Array_Head + var1 + Team_Tech_Array_Size * var2] |= var3

}



//##########################
// Player commands
//##########################

//$playerid is for future possible multiplayer expantion - 0 = singleplay

def {
	DIS_playerid_singleplay = 0

}


__fn cmd_player_change_view $playerid $tileX $tileY {
	t[__id($tileX)].toNum var1 
	t[__id($tileY)].toNum var2 
	@map[LEGV_MAPID].setVehiclePos .boat .pos var1, var2 .retain
	LEGV_CamWarpx = boat.x
	LEGV_CamWarpy = boat.y
	LEGS_Call_CameraWarp.on
}

//$vic_or_def 1 = def, 2 = vic 
__fn cmd_player_prepare_endgame $playerid $vic_or_def { // Cmd.mission.endMission
	t2v($vic_or_def,var1)
	@if var1 == 1 { // victory
		v[2820] = var1
		@call .cev 2135 //wut?
	}.elif var1 == 2 { // defeat
		v[2820] = var1
		@call .cev 2135 
	}.else bl {
		func_errlog("player_prepare_endgame: End game condition seems illegal or undefined")
		
	}

}

// you can quit mission by pressing [TAB] after this function executed
__fn cmd_mission_set_end_flag { //Cmd.mission.allowToQuit
	@pic[PicID_VicDef].move {
	    .pos LEGV_ConstScreenCenterY, LEGV_ConstScreenCenterY .center
	    .scale 100
	    .trans 100
	    .time 15
	    .rgbs 100, 100, 100, 100
	}
	LEGS_SkipBriefing.on //?

}




