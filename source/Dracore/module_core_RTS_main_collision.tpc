//Collision check

// these are retarded and must be purged tbh tbfh
def Const_AgentMetaTeam_beginMINUSONE = Const_AgentMetaTeam_begin - 1
def Address_Agent_HitCollisionArrayStartMinus2 = Address_Agent_HitCollisionArrayStart - 2 

def Const_ColPushA=-980 //-950
def Const_ColPushB=-1400 //-1350

def Const_ColPushA2=-1470 //-1425
def Const_ColPushB2=-2100 //-2025

def Const_ColPushA3=-1960 //-1900
def Const_ColPushB3=-2800 //-2700



// cev .id(68),.name("Main:Agents Collision"),.parallel , .cond(Const_Is_RTS_Mode), {
__fn MAIN_CEV_RTS_COLLISION_MANAGER { // -> 
	@comment "module_core_RTS_collision.tpc"
	@if v[204] < 400 {
			v[527] = Const_ColPushA
			v[528] = Const_ColPushB
			@if s[2] .isOff() {
		//@comment "Even Normal Units Collision "
		v[536] = v[4532]
		@while v[v[536]] != 0 {
				v[401] = v[v[536]] - 1
				Temp1 = v[401] * v[1117] 
				Temp1 += 5000
				//@comment "#Col"
				ColCheck()
				//@comment "++"
				v[536] += 2
				
		}
		
		
			}

			@wait 0
			@if s[2] .isOff() {
		//@comment "Odd Normal Units Collision "
		v[536] = v[4532] + 1
		@while v[v[536]] != 0 {
				v[401] = v[v[536]] - 1
				Temp1 = v[401] * v[1117] 
				Temp1 += 5000
				//@comment "#Col"
				ColCheck()
				//@comment "++"
				v[536] += 2
				
		}
		
		
			}
			
	} .else bl {
			@if v[204] < 600 {
		v[527] = Const_ColPushA2
		v[528] = Const_ColPushB2

		@if s[2] .isOff() {
				//@comment "Even Normal Units Collision "
				v[536] = v[4532]
				@while v[v[536]] != 0 {
			v[401] = v[v[536]] - 1
			Temp1 = v[401] * v[1117] 
			Temp1 += 5000
			//@comment "#Col"
				ColCheck()
			//@comment "++"
			v[536] += 3
			
				}
				
				
		}

		@wait 0
		@if s[2] .isOff() {
				//@comment "Odd Normal Units Collision "
				v[536] = v[4532] + 1
				@while v[v[536]] != 0 {
			v[401] = v[v[536]] - 1
			Temp1 = v[401] * v[1117]
			Temp1 += 5000
			//@comment "#Col"
			ColCheck()
			//@comment "++"
			v[536] += 3
			
				}
				
				
		}
		@wait 0
		@if s[2] .isOff() {
				//@comment "Odd Normal Units Collision "
				v[536] = v[4532] + 2
				@while v[v[536]] != 0 {
			v[401] = v[v[536]] - 1
			Temp1 = v[401] * v[1117]
			Temp1 += 5000
			//@comment "#Col"
			ColCheck()
			//@comment "++"
			v[536] += 3
			
				}
				
				
		}
		
			} .else bl {
		v[527] = Const_ColPushA3
		v[528] = Const_ColPushB3
		@if s[2] .isOff() {
				//@comment "Even Normal Units Collision "
				v[536] = v[4532]
				@while v[v[536]] != 0 {
			v[401] = v[v[536]] - 1
			Temp1 = v[401] * v[1117] 
			Temp1 += 5000
			//@comment "#Col"
			ColCheck()
			//@comment "++"
			v[536] += 4
			
				}
				
				
		}
		@wait 0
		@if s[2] .isOff() {
				//@comment "Odd Normal Units Collision "
				v[536] = v[4532] + 1
				@while v[v[536]] != 0 {
			v[401] = v[v[536]] - 1
			Temp1 = v[401] * v[1117] 
			Temp1 += 5000
			//@comment "#Col"
			ColCheck()
			//@comment "++"
			v[536] += 4
			
				}
				
				
		}
		@wait 0
		@if s[2] .isOff() {
				//@comment "Odd Normal Units Collision "
				v[536] = v[4532] + 2
				@while v[v[536]] != 0 {
			v[401] = v[v[536]] - 1
			Temp1 = v[401] * v[1117] 
			Temp1 += 5000
			//@comment "#Col"
			ColCheck()
			//@comment "++"
			v[536] += 4
			
				}
				
				
		}
		@wait 0
		@if s[2] .isOff() {
				//@comment "Odd Normal Units Collision "
				v[536] = v[4532] + 3
				@while v[v[536]] != 0 {
			v[401] = v[v[536]] - 1
			Temp1 = v[401] * v[1117] 
			Temp1 += 5000
			//@comment "#Col"
			ColCheck()
			//@comment "++"
			v[536] += 4
			
				}
				
				
		}
		
			}
			
	}
}





__fn ColCheck {
	// extract agent data....
	v[Temp1].copy v[600], 243
	@if `(v[401] + LEGV_Frame_count_half) % v[625] == 0 {

			//save ptr to slot3
			//ptr to agent_AgentBits.
			defv Col_Ptr2AgentBits = __id(Temp32) 
			Col_Ptr2AgentBits = Temp1 + 3
			v[Col_Ptr2AgentBits] &= -193 //~192
			//@if `v[v[4529] + v[632]] & 1 { // this part seems retarded so need to remake
			@if `agent_AgentBits & AgentBits_FLAG_Pushed_by_terrain {
				Ptr18 = Temp1 + 7
				Ptr20 = Temp1 + 5
				Ptr15 = Temp1 + 296
				Ptr16 = Temp1 + 36
				Ptr17 = 53
				v[Col_Ptr2AgentBits] |= AgentBits_Collided_Other_Agent
				//kabe no naka ni iru!
				@ev[2].setPos .pos v[626], v[627]
				Temp16 = ev[2].scrx
				Temp17 = ev[2].scry
				Temp17 -= 16
				v[Ptr18].copy v[321], 2
				v[321] .sub Temp16, 2
				v[321..322] *= 3000
				v[Ptr20] .add v[321], 2
				v[Ptr20] += v[Ptr17] * 10000
				v[Ptr18] = v[Ptr20] / 10000
				v[Ptr16] = v[Ptr18] + v[Ptr15]
				v[295..300] += 1
				v[Ptr20] += v[Ptr17] * 10000
				v[Ptr18] = v[Ptr20] / 10000
				v[Ptr16] = v[Ptr18] + v[Ptr15]
				v[Col_Ptr2AgentBits] &= ~AgentBits_FLAG_Pushed_by_terrain
						
				
			} .else bl {
				//Obj Collision


				Temp19 = v[401]
				
				//######################
				//Check Morton Start
				//######################
				v[607].copy TT1, 2
				TT1 .sub v[610], 2

				//#########################
				//#2002 Crd->Mort V1V2 reg1
				//#########################
				//var1.copy TT1, 2
				TT1 .sub v[76], 2
				TT1 .div v[74], 2
				//TT1=MortX
				//TT2=MortY
				//ビット演算して処理するよ
				TT1 = (TT1 | TT1 << 8) & 0xFF00FF
				TT1 = (TT1 | TT1 << 4) & 0xF0F0F0F
				TT1 = (TT1 | TT1 << 2) & 0x33333333
				TT1 = (TT1 | TT1 << 1) & 0x55555555
				TT2 = (TT2 | TT2 << 8) & 0xFF00FF
				TT2 = (TT2 | TT2 << 4) & 0xF0F0F0F
				TT2 = (TT2 | TT2 << 2) & 0x33333333
				TT2 = ((TT2 | TT2 << 1) & 0x55555555) << 1
				//@comment "yは1bitシフトで終わり"
				//TT2 <<= 1
				//@comment "最後にTT1 OR TT2"
				//opt 28.4.23
				//reg1 = TT1 | TT2
				//TT11 = reg1
				TT11 = TT1 | TT2
				v[607].copy TT1, 2
				TT1 .add v[610], 2
				//@comment "#########################
				//#2002 Crd->Mort V1V2 reg1
				//##########################"
				TT1 .sub v[76], 2
				TT1 .div v[74], 2
				//@comment "TT1=MortX
				//TT2=MortY
				//ビット演算して処理するよ"
				TT1 = (TT1 | TT1 << 8) & 0xFF00FF
				TT1 = (TT1 | TT1 << 4) & 0xF0F0F0F
				TT1 = (TT1 | TT1 << 2) & 0x33333333
				TT1 = (TT1 | TT1 << 1) & 0x55555555
				TT2 = (TT2 | TT2 << 8) & 0xFF00FF
				TT2 = (TT2 | TT2 << 4) & 0xF0F0F0F
				TT2 = (TT2 | TT2 << 2) & 0x33333333
				TT2 = ((TT2 | TT2 << 1) & 0x55555555) << 1
				//@comment "yは1bitシフトで終わり"
				//@comment "最後にTT1 OR TT2"

				TT2 = TT1 | TT2
				//@comment "TT1 = upper left morton
				//TT2 = bottom right morton
				//TT5 = shift num"
				TT3 = TT11 ^ TT2
				//@comment "#mask with 11000000
				//@comment ""#mask with 110000""
				//@comment ""#mask with 001100""
				//@comment ""#mask with 000011"""
				
				TT5 = TT3 & 768 ? 10 : TT3 & 192 ? 8 : TT3 & 48 ? 6 : TT3 & 12 ? 4 : TT3 & 3 ? 2 : 0
				agent_Morton = TT2 >> TT5
				//@comment "#mask end"
				TT6 = TT5 / 2
				v[340] = 4546 - TT6
				v[340].deref v[340],1
				v[327] = v[v[4552 - TT6] + agent_Morton]
				//@comment "##############"
				Ptr14 = Temp1 + 25
				v[Ptr14] = 2 + v[327] / v[4522] + v[610] / 19 - s[2001 + v[401]] + (v[842] >= 3 && v[680] <= 0) // (v[842] >= 3 && v[680] <= 0 ? 1 : 0)
					//@comment "DisciplineCheck"
				//opt

				// set real agentid to TT2 
				TT2 = v[v[536]]

				//GET Colbox XY
				__if DIS_EXPERIMENTAL == -1 {
					//get from AEAB
					get_AEAB_array(TT2,__id(v[337]),AgentExBuffer_SLOT_ColBoxWidth,2)
				}.else bl {
					v[337] = v[4523] 
					v[337] += v[401] * 2
					v[v[337]].copy v[337], 2
				}

				//v[339] as a ptr
				v[339] = agent_Morton * v[1004] 
				v[339] += v[340]

				//experimental
				Ptr5 = Const_save_var_TileFlags + v[632]
				@if `v[Ptr5] & FLAG_Maptile_Crowded {
					// shuffling too much size array causes lag so set limitation on the max num
					TT1 = min(v[327],8) // changed 16 -> 8
					v[v[339]].shuffle TT1
				}
				
				//v[203] = Ptr
				v[203] = v[339] //set &array[0]

				// set pointer for push
				Ptr19 = Temp1 + 15
				@if `v[Col_Ptr2AgentBits] & AgentBits_Discipline_Col { // the agent has discipline?

						// if so
						@loop v[327] {

							__if DIS_EXPERIMENTAL == -1 {
								// DIS_EXPERIMENTAL - get MetaTeam from AEAB inTT3
								TT3 = v[v[203]]
								get_AEAB_element(TT3,__id(TT3),AgentExBuffer_SLOT_MetaTeam)
							}

							//@if v[700] != TT3 { // EXPERIMENTAL cond

							// cond in case of NOT DIS_EXPERIMENTAL.. you must adjust manually
							@if `agent_TeamID != v[v[v[203]] + Const_AgentMetaTeam_beginMINUSONE] {
						
								macro_ColCheck_distance()

								@if `v[322] + v[337] >= abs(victim_RelativeX) {
									@if `v[323] + v[338] >= abs(victim_RelativeY) {
										macro_ColCheck_push()
									}
									
								}
								
							}
							v[203] += 1 //++
							
						}
						
						
				} .else bl {
						@loop v[327] {
							@if TT2 != v[v[203]] { //not unit itself

								macro_ColCheck_distance()

								@if `v[322] + v[337] >= abs(victim_RelativeX) {
									@if `v[323] + v[338] >= abs(victim_RelativeY) {
										macro_ColCheck_push()
										
									}
									
								}
								
							}
							v[203] += 1 //++
						}
						
						
				}
				
				/*
				@if `!(v[Col_Ptr2AgentBits] & AgentBits_Collided_Other_Agent) { // NOT collided
					v[Col_Ptr2AgentBits] &= -385 // ~384
					
				}
				*/
				
				v[Col_Ptr2AgentBits] &= v[Col_Ptr2AgentBits] & AgentBits_Collided_Other_Agent ? v[Col_Ptr2AgentBits] : -385 // is this really faster than above?

				
			}
			
	}


}



__fn macro_ColCheck_distance {
	/*
	Temp20 = v[v[203]] * 300
	Temp20 += 4707
	v[Temp20].copy Temp20,2
	Temp20.sub v[607],2
	*/

	victim_AgentType = v[v[203]] * 300
	victim_AgentType += 4701
	v[victim_AgentType].copy victim_AgentType,102
	victim_RelativeX.sub agent_RelativeX,2

	//get colbox
	__if DIS_EXPERIMENTAL == -1 { // pixel edit bug
		//get from AEAB
		v[322] = v[v[203]]
		get_AEAB_array(v[322],__id(v[322]),AgentExBuffer_SLOT_ColBoxWidth,2)
	}.elif DIS_EXPERIMENTAL == -2 { // use raw hitbox as a collision?
		victim_Width.copy v[322],2
	}.else bl {
		v[322] = Address_Agent_HitCollisionArrayStartMinus2 
		v[322] += v[v[203]] * 2
		v[v[322]].copy v[322],2
	}

	//func_devlog("\v[\v[203]]: \v[322] \v[323] \Temp20 \v[321]")

}

__fn macro_ColCheck_push {

	// if the agents are in the completely same coordinate
	@if victim_RelativeX == 0 {
		@if victim_RelativeY == 0 {
			// then push it to random direction
			victim_RelativeX = rnd(-2,2) 
			victim_RelativeY = rnd(-2,2)
		}
	}

	v[__id(victim_RelativeX)..__id(victim_RelativeY)] *= (v[527 + (((v[Col_Ptr2AgentBits] | (agent_MoveTypeBIts & MoveTypeBits_Horse && agent_InCombatTimer > 0 ? 256 : 0)) & 256) >> 8)]) + ((v[Ptr5] & FLAG_Maptile_Crowded) >> 1) // if it's Crowded, push more
	v[Ptr19] .add victim_RelativeX, 2
	
	defv Col_Ptr2AI_routine_bits = __id(Temp33) 
	@if victim_AgentType == 11 { // pushed by static agent
		@if agent_MovementOrder > MovementOrder_TYPE_move_ordered
			@if v[v[203]] != agent_TargetAgentID { // NOT target
				@if victim_TeamID == agent_TeamID { // and it's ally
					Col_Ptr2AI_routine_bits = Temp1 + 34
					def Col_AIFLAG_PFandSkip = AI_routine_bits_FLAG_PATHFINDING + AI_routine_bits_FLAG_1secDelay_PF
					v[Col_Ptr2AI_routine_bits] |= agent_LeftWPtoChase > 0 ? Col_AIFLAG_PFandSkip : AI_routine_bits_FLAG_PATHFINDING

				}
			}
		}
	}

	v[Col_Ptr2AgentBits] |= AgentBits_Collided_Other_Agent
	@break
}
