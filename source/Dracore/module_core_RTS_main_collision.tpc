<<<<<<< HEAD
//Collision check

def Const_ColPushA=-980 //-950
def Const_ColPushB=-1400 //-1350

def Const_ColPushA2=-1470 //-1425
def Const_ColPushB2=-2100 //-2025

def Const_ColPushA3=-1960 //-1900
def Const_ColPushB3=-2800 //-2700


__fn macro_ColCheck_distance {

    v[320] = v[v[320]] - v[607]
    v[321] = v[v[321]] - v[608]
    v[322] = v[4523] 
    v[322] += v[203] *2
    //v[v[322]].copy v[322], 2
    //v[321] = v[203] * 300
    v[320] = v[(v[203] * 300)+v[1607]] - v[607]
    //v[321] = v[(v[203] * 300)+v[1608]] - v[v[334]]
}

__fn macro_ColCheck_push {
    //24.4.23

    //v[320].copy v[325], 2
    //v[325..326] *= v[527 + ((v[v[603]] | (v[v[603] + 35] & 2 && v[v[603] + 77] > 0 ? 256 : 0)) & 256) / 256]
    //v[v[299]] .add v[325], 2

    //v[320].copy v[325], 2

    //opt 11.5.23
    //v[320..321] *= v[527 + ((v[v[603]] | (v[v[603] + 35] & 2 && v[v[603] + 77] > 0 ? 256 : 0)) & 256) / 256]
    //TT1 = Const_save_var_TileFlags+v[632]//check Tile flag
    v[320..321] *= (v[527 + ((v[Temp32] | (v[638] & 2 && v[680] > 0 ? 256 : 0)) & 256) / 256]) + (v[Ptr5]&FLAG_Maptile_Crowded?1:0)//if it's Crowded, push more
    v[v[299]] .add v[320], 2
    v[Temp32] |= 64
    @break
}

__fn ColCheck {

v[294] = v[301] + 25
@if `(v[401] + v[2501] / 2) % v[v[294]] == 0 {
    v[299] = v[301] + 15
    v[298] = v[301] + 7
    //
    //save ptr to slot3
    Temp32 = v[301] + 3
    v[Temp32] &= -193//~192
    //get map XY
    //v[293] = v[301] + 26
    //v[v[293]].copy v[311], 2
    v[v[301]].copy v[600], 243
    @if `v[v[4529] + v[632]] & 1 {
        @if `v[53] * 1000 + v[54] == 0 {
    	    v[300] = v[301] + 5
    	    v[295] = v[301] + 296
    	    v[296] = v[301] + 36
    	    v[297] = 53
            v[Temp32] |= 64
            //kabe no naka ni iru!
            @ev[2].setPos .pos v[626], v[627]
            v[316] = ev[2].scrx
            v[317] = ev[2].scry
            v[317] -= 16
            v[v[298]].copy v[321], 2
            v[321] .sub v[316], 2
            v[321..322] *= 2800
            v[v[300]] .add v[321], 2
            v[v[300]] += v[v[297]] * 10000
            v[v[298]] = v[v[300]] / 10000
            v[v[296]] = v[v[298]] + v[v[295]]
            v[295..300] += 1
            v[v[300]] += v[v[297]] * 10000
            v[v[298]] = v[v[300]] / 10000
            v[v[296]] = v[v[298]] + v[v[295]]
            v[295..300] -= 1
            
        }
        
    } .else bl {
        //Obj Collision


        v[319] = v[401]
        //v[333] = v[301] + 7
        //v[334] = v[301] + 8
        //v[335] = v[301] + 10
        //v[336] = v[301] + 11
        //v[842] = v[301] + 242
        //v[337] = v[301] + 80
        
        //######################
        //Check Morton Start
        //######################
        //v[607] = v[333]
        //v[610] = v[335]
        //v[v[607]].copy v[11], 2
	v[607].copy v[341], 2
        v[341] .sub v[610], 2
        //#########################
        //#2002 Crd->Mort V1V2 reg1
        //#########################
        //v[11].copy v[341], 2
        v[341] .sub v[76], 2
        v[341] .div v[74], 2
        //TT1=MortX
        //TT2=MortY
        //ビット演算して処理するよ
        v[341] = (v[341] | v[341] << 8) & 0xFF00FF
        v[341] = (v[341] | v[341] << 4) & 0xF0F0F0F
        v[341] = (v[341] | v[341] << 2) & 0x33333333
        v[341] = (v[341] | v[341] << 1) & 0x55555555
        v[342] = (v[342] | v[342] << 8) & 0xFF00FF
        v[342] = (v[342] | v[342] << 4) & 0xF0F0F0F
        v[342] = (v[342] | v[342] << 2) & 0x33333333
        v[342] = ((v[342] | v[342] << 1) & 0x55555555) << 1
        //@comment "yは1bitシフトで終わり"
        //v[342] <<= 1
        //@comment "最後にTT1 OR TT2"
	//opt 28.4.23
        //v[21] = v[341] | v[342]
        //v[351] = v[21]
	v[351] = v[341] | v[342]
        v[607].copy v[341], 2
        v[341] .add v[610], 2
        //@comment "#########################
        //#2002 Crd->Mort V1V2 reg1
        //##########################"
        //v[11].copy v[341], 2
        v[341] .sub v[76], 2
        v[341] .div v[74], 2
        //@comment "TT1=MortX
        //TT2=MortY
        //ビット演算して処理するよ"
        v[341] = (v[341] | v[341] << 8) & 0xFF00FF
        v[341] = (v[341] | v[341] << 4) & 0xF0F0F0F
        v[341] = (v[341] | v[341] << 2) & 0x33333333
        v[341] = (v[341] | v[341] << 1) & 0x55555555
        v[342] = (v[342] | v[342] << 8) & 0xFF00FF
        v[342] = (v[342] | v[342] << 4) & 0xF0F0F0F
        v[342] = (v[342] | v[342] << 2) & 0x33333333
        v[342] = ((v[342] | v[342] << 1) & 0x55555555) << 1
        //@comment "yは1bitシフトで終わり"
        //v[342] <<= 1
        //@comment "最後にTT1 OR TT2"

	//opt 28.4.23
        //v[21] = v[341] | v[342]
        //v[341] = v[351]
        //v[342] = v[21]
	v[342] = v[341] | v[342]
        //@comment "TT1 = upper left morton
        //TT2 = bottom right morton
        //TT5 = shift num"
        v[343] = v[351] ^ v[342]
        //@comment "#mask with 11000000
        //@comment ""#mask with 110000""
        //@comment ""#mask with 001100""
        //@comment ""#mask with 000011"""
        v[345] = v[343] & 768 ? 10 : v[343] & 192 ? 8 : v[343] & 48 ? 6 : v[343] & 12 ? 4 : v[343] & 3 ? 2 : 0
        v[609] = v[342] >> v[345]
        //@comment "#mask end"
	v[346] = v[345] / 2
	//opt 28.4.23
        //v[340] = v[4546 - v[346]]
	v[340] = 4546 - v[346]
        v[340] = v[v[340]]
        v[327] = v[v[4552 - v[346]] + v[609]]
        //@comment "##############"
        v[v[294]] = 2 + v[327] / v[4522] + v[610] / 19 - s[2001 + v[401]] + (v[842] >= 3 && v[680] <= 0 ? 1 : 0)
        //v[v[294]] = 2 + v[327] / v[4522] + v[v[335]] / 19 - s[2001 + v[401]] + (v[v[842]] >= 3 && v[v[337]] <= 0 ? 1 : 0)
        //@comment "DisciplineCheck"
	//opt
        v[337] = v[4523] 
	v[337] += v[401] * 2
        v[v[337]].copy v[337], 2
	//v[339] as a ptr
        v[339] = v[609] * v[1004] 
	v[339] += v[340]

	//experimental
	Ptr5 = Const_save_var_TileFlags+v[632]
	@if `v[Ptr5]&FLAG_Maptile_Crowded{
		TT1 = min(v[327],16) // shuffling too much size allay causes lag so set limitation on the max num
		v[v[339]].shuffle TT1
	}

        @if `v[Temp32] & 512 { //has discipline 
	    //v[700] = v[301] + 100
            //v[700] = v[v[700]]
            @loop v[327] .dst v[342] {
                v[203] = v[v[339] + v[342]] - 1
                @if `v[700] != v[v[203]+ Const_AgentMetaTeam_begin ] { //v[v[203] * 300 + 5100] {

		    macro_ColCheck_distance()

                    //@if `v[322] + v[337] >= abs(v[320]) {
                        //@if `v[323] + v[338] >= abs(v[321]) {
		      @if `v[v[322]] + v[337] >= abs(v[320]) {
			  //25.4.23
			  //v[321] = v[(v[203] * 300)+v[1608]] - v[v[334]]
			  v[321] = v[(v[203] * 300)+v[1608]] - v[608]
                          @if `v[v[322]+1] + v[338] >= abs(v[321]) {
			    macro_ColCheck_push()
                        }
                        
                    }
                    
                }
                
            }
            
            
        } .else bl {
            @loop v[327] .dst v[342] {
                v[203] = v[v[339] + v[342]] - 1
                @if v[319] != v[203] { //not unit itself

		    macro_ColCheck_distance()

                    //@if `v[322] + v[337] >= abs(v[320]) {
                    //    @if `v[323] + v[338] >= abs(v[321]) {
                    @if `v[v[322]] + v[337] >= abs(v[320]) {
			//25.4.23
			//v[321] = v[(v[203] * 300)+v[1608]] - v[v[334]]
			v[321] = v[(v[203] * 300)+v[1608]] - v[608]
                        @if `v[v[322]+1] + v[338] >= abs(v[321]) {

			    macro_ColCheck_push()
                            
                        }
                        
                    }
                    
                }
                
            }
            
            
        }
        @if `!(v[Temp32] & 64) {
            v[Temp32] &= -385//~384
            
        }
        
    }
    
}


}



cev .id(68),.name("Main:Agents Collision"),.parallel , .cond(Const_Is_RTS_Mode), {
@comment "module_core_RTS_collision.tpc"
@if v[204] < 400 {
    v[527] = Const_ColPushA
    v[528] = Const_ColPushB
    @if s[2] .isOff() {
        //@comment "Even Normal Units Collision "
        v[536] = v[4532]
        @while v[v[536]] != 0 {
            v[401] = v[v[536]] - 1
            v[301] = v[401] * v[1117] 
	    v[301] += 5000
            //@comment "#Col"
            ColCheck()
            //@comment "++"
            v[536] += 2
            
        }
        
        
    }
    @wait 0
    @if s[2] .isOff() {
        //@comment "Odd Normal Units Collision "
        v[536] = v[4532] + 1
        @while v[v[536]] != 0 {
            v[401] = v[v[536]] - 1
            v[301] = v[401] * v[1117] 
	    v[301] += 5000
            //@comment "#Col"
            ColCheck()
            //@comment "++"
            v[536] += 2
            
        }
        
        
    }
    
} .else bl {
    @if v[204] < 600 {
        v[527] = Const_ColPushA2
        v[528] = Const_ColPushB2
        @if s[2] .isOff() {
            //@comment "Even Normal Units Collision "
            v[536] = v[4532]
            @while v[v[536]] != 0 {
                v[401] = v[v[536]] - 1
                v[301] = v[401] * v[1117] 
	    	v[301] += 5000
                //@comment "#Col"
            ColCheck()
                //@comment "++"
                v[536] += 3
                
            }
            
            
        }
        @wait 0
        @if s[2] .isOff() {
            //@comment "Odd Normal Units Collision "
            v[536] = v[4532] + 1
            @while v[v[536]] != 0 {
                v[401] = v[v[536]] - 1
                v[301] = v[401] * v[1117]
	    	v[301] += 5000
                //@comment "#Col"
            	ColCheck()
                //@comment "++"
                v[536] += 3
                
            }
            
            
        }
        @wait 0
        @if s[2] .isOff() {
            //@comment "Odd Normal Units Collision "
            v[536] = v[4532] + 2
            @while v[v[536]] != 0 {
                v[401] = v[v[536]] - 1
                v[301] = v[401] * v[1117]
	    	v[301] += 5000
                //@comment "#Col"
            	ColCheck()
                //@comment "++"
                v[536] += 3
                
            }
            
            
        }
        
    } .else bl {
        v[527] = Const_ColPushA3
        v[528] = Const_ColPushB3
        @if s[2] .isOff() {
            //@comment "Even Normal Units Collision "
            v[536] = v[4532]
            @while v[v[536]] != 0 {
                v[401] = v[v[536]] - 1
                v[301] = v[401] * v[1117] 
	    	v[301] += 5000
                //@comment "#Col"
            	ColCheck()
                //@comment "++"
                v[536] += 4
                
            }
            
            
        }
        @wait 0
        @if s[2] .isOff() {
            //@comment "Odd Normal Units Collision "
            v[536] = v[4532] + 1
            @while v[v[536]] != 0 {
                v[401] = v[v[536]] - 1
                v[301] = v[401] * v[1117] 
	    	v[301] += 5000
                //@comment "#Col"
            	ColCheck()
                //@comment "++"
                v[536] += 4
                
            }
            
            
        }
        @wait 0
        @if s[2] .isOff() {
            //@comment "Odd Normal Units Collision "
            v[536] = v[4532] + 2
            @while v[v[536]] != 0 {
                v[401] = v[v[536]] - 1
                v[301] = v[401] * v[1117] 
	    	v[301] += 5000
                //@comment "#Col"
            	ColCheck()
                //@comment "++"
                v[536] += 4
                
            }
            
            
        }
        @wait 0
        @if s[2] .isOff() {
            //@comment "Odd Normal Units Collision "
            v[536] = v[4532] + 3
            @while v[v[536]] != 0 {
                v[401] = v[v[536]] - 1
                v[301] = v[401] * v[1117] 
	    	v[301] += 5000
                //@comment "#Col"
            	ColCheck()
                //@comment "++"
                v[536] += 4
                
            }
            
            
        }
        
    }
    
}
}


=======
//Collision check

// these are retarded and must be purged tbh tbfh
def Const_AgentMetaTeam_beginMINUSONE = Const_AgentMetaTeam_begin - 1
def Address_Agent_HitCollisionArrayStartMinus2 = Address_Agent_HitCollisionArrayStart - 2 

def Const_ColPushA=-980 //-950
def Const_ColPushB=-1400 //-1350

def Const_ColPushA2=-1470 //-1425
def Const_ColPushB2=-2100 //-2025

def Const_ColPushA3=-1960 //-1900
def Const_ColPushB3=-2800 //-2700



// cev .id(68),.name("Main:Agents Collision"),.parallel , .cond(Const_Is_RTS_Mode), {
__fn MAIN_CEV_RTS_COLLISION_MANAGER { // -> 
	@comment "module_core_RTS_collision.tpc"
	@if v[204] < 400 {
			v[527] = Const_ColPushA
			v[528] = Const_ColPushB
			@if s[2] .isOff() {
				//@comment "Even Normal Units Collision "
				v[536] = v[4532]
				@while v[v[536]] != 0 {
						v[401] = v[v[536]] - 1
						Temp1 = v[401] * v[1117] 
						val_add(Temp1,N5000) // Temp1 += 5000
						//@comment "#Col"
						ColCheck()
						//@comment "++"
						// v[536] += 2
						val_add(v[536],N2) // v[536] += 2
						
				}
				
				
			}

			@wait 0
			@if s[2] .isOff() {
				//@comment "Odd Normal Units Collision "
				v[536] = v[4532] + 1
				@while v[v[536]] != 0 {
						v[401] = v[v[536]] - 1
						Temp1 = v[401] * v[1117] 
						val_add(Temp1,N5000) // Temp1 += 5000
						//@comment "#Col"
						ColCheck()
						//@comment "++"
						val_add(v[536],N2) // v[536] += 2
						
				}
				
		
			}
			
	} .else bl {
			@if v[204] < 600 {
				v[527] = Const_ColPushA2
				v[528] = Const_ColPushB2

				@if s[2] .isOff() {
						//@comment "Even Normal Units Collision "
						v[536] = v[4532]
						@while v[v[536]] != 0 {
							v[401] = v[v[536]] - 1
							Temp1 = v[401] * v[1117] 
							val_add(Temp1,N5000) // Temp1 += 5000
							//@comment "#Col"
								ColCheck()
							//@comment "++"
							v[536] += 3
							
						}
						
						
				}

				@wait 0
				@if s[2] .isOff() {
						//@comment "Odd Normal Units Collision "
						v[536] = v[4532] + 1
						@while v[v[536]] != 0 {
							v[401] = v[v[536]] - 1
							Temp1 = v[401] * v[1117]
							val_add(Temp1,N5000) // Temp1 += 5000
							//@comment "#Col"
							ColCheck()
							//@comment "++"
							v[536] += 3
							
						}
						
						
				}
				@wait 0
				@if s[2] .isOff() {
						//@comment "Odd Normal Units Collision "
						v[536] = v[4532] + 2
						@while v[v[536]] != 0 {
							v[401] = v[v[536]] - 1
							Temp1 = v[401] * v[1117]
							val_add(Temp1,N5000) // Temp1 += 5000
							//@comment "#Col"
							ColCheck()
							//@comment "++"
							v[536] += 3
					
						}
						
						
				}
				
			} .else bl {
		v[527] = Const_ColPushA3
		v[528] = Const_ColPushB3
		@if s[2] .isOff() {
				//@comment "Even Normal Units Collision "
				v[536] = v[4532]
				@while v[v[536]] != 0 {
					v[401] = v[v[536]] - 1
					Temp1 = v[401] * v[1117] 
					Temp1 += 5000
					//@comment "#Col"
					ColCheck()
					//@comment "++"
					v[536] += 4
			
				}
				
				
		}
		@wait 0
		@if s[2] .isOff() {
				//@comment "Odd Normal Units Collision "
				v[536] = v[4532] + 1
				@while v[v[536]] != 0 {
			v[401] = v[v[536]] - 1
			Temp1 = v[401] * v[1117] 
			Temp1 += 5000
			//@comment "#Col"
			ColCheck()
			//@comment "++"
			v[536] += 4
			
				}
				
				
		}
		@wait 0
		@if s[2] .isOff() {
				//@comment "Odd Normal Units Collision "
				v[536] = v[4532] + 2
				@while v[v[536]] != 0 {
			v[401] = v[v[536]] - 1
			Temp1 = v[401] * v[1117] 
			Temp1 += 5000
			//@comment "#Col"
			ColCheck()
			//@comment "++"
			v[536] += 4
			
				}
				
				
		}
		@wait 0
		@if s[2] .isOff() {
				//@comment "Odd Normal Units Collision "
				v[536] = v[4532] + 3
				@while v[v[536]] != 0 {
			v[401] = v[v[536]] - 1
			Temp1 = v[401] * v[1117] 
			Temp1 += 5000
			//@comment "#Col"
			ColCheck()
			//@comment "++"
			v[536] += 4
			
				}
				
				
		}
		
			}
			
	}
}





__fn ColCheck {
	// extract agent data....
	v[Temp1].copy v[600], 243
	@if `(v[401] + LEGV_Frame_count_half) % v[625] == 0 {

			//save ptr to slot3
			//ptr to agent_AgentBits.
			defv Col_Ptr2AgentBits = __id(Temp32) 
			Col_Ptr2AgentBits = Temp1 + 3
			v[Col_Ptr2AgentBits] &= -193 //~192
			//@if `v[v[4529] + v[632]] & 1 { // this part seems retarded so need to remake
			@if `agent_AgentBits & AgentBits_FLAG_Pushed_by_terrain {
				Ptr18 = Temp1 + 7
				Ptr20 = Temp1 + 5
				Ptr15 = Temp1 + 296
				Ptr16 = Temp1 + 36
				Ptr17 = 53
				v[Col_Ptr2AgentBits] |= AgentBits_Collided_Other_Agent
				//kabe no naka ni iru!
				@ev[2].setPos .pos v[626], v[627]
				Temp16 = ev[2].scrx
				Temp17 = ev[2].scry
				Temp17 -= 16
				v[Ptr18].copy v[321], 2
				v[321] .sub Temp16, 2
				v[321..322] *= 3000
				v[Ptr20] .add v[321], 2
				v[Ptr20] += v[Ptr17] * 10000
				v[Ptr18] = v[Ptr20] / 10000
				v[Ptr16] = v[Ptr18] + v[Ptr15]
				v[295..300] += 1
				v[Ptr20] += v[Ptr17] * 10000
				v[Ptr18] = v[Ptr20] / 10000
				v[Ptr16] = v[Ptr18] + v[Ptr15]
				v[Col_Ptr2AgentBits] &= ~AgentBits_FLAG_Pushed_by_terrain
						
				
			} .else bl {
				//Obj Collision


				Temp19 = v[401]
				
				//######################
				//Check Morton Start
				//######################
				v[607].copy TT1, 2
				TT1 .sub v[610], 2

				//#########################
				//#2002 Crd->Mort V1V2 reg1
				//#########################
				//var1.copy TT1, 2
				TT1 .sub v[76], 2
				TT1 .div v[74], 2
				//TT1=MortX
				//TT2=MortY
				//ビット演算して処理するよ
				TT1 = (TT1 | TT1 << 8) & 0xFF00FF
				TT1 = (TT1 | TT1 << 4) & 0xF0F0F0F
				TT1 = (TT1 | TT1 << 2) & 0x33333333
				TT1 = (TT1 | TT1 << 1) & 0x55555555
				TT2 = (TT2 | TT2 << 8) & 0xFF00FF
				TT2 = (TT2 | TT2 << 4) & 0xF0F0F0F
				TT2 = (TT2 | TT2 << 2) & 0x33333333
				TT2 = ((TT2 | TT2 << 1) & 0x55555555) << 1
				//@comment "yは1bitシフトで終わり"
				//TT2 <<= 1
				//@comment "最後にTT1 OR TT2"
				//opt 28.4.23
				//reg1 = TT1 | TT2
				//TT11 = reg1
				TT11 = TT1 | TT2
				v[607].copy TT1, 2
				TT1 .add v[610], 2
				//@comment "#########################
				//#2002 Crd->Mort V1V2 reg1
				//##########################"
				TT1 .sub v[76], 2
				TT1 .div v[74], 2
				//@comment "TT1=MortX
				//TT2=MortY
				//ビット演算して処理するよ"
				TT1 = (TT1 | TT1 << 8) & 0xFF00FF
				TT1 = (TT1 | TT1 << 4) & 0xF0F0F0F
				TT1 = (TT1 | TT1 << 2) & 0x33333333
				TT1 = (TT1 | TT1 << 1) & 0x55555555
				TT2 = (TT2 | TT2 << 8) & 0xFF00FF
				TT2 = (TT2 | TT2 << 4) & 0xF0F0F0F
				TT2 = (TT2 | TT2 << 2) & 0x33333333
				TT2 = ((TT2 | TT2 << 1) & 0x55555555) << 1
				//@comment "yは1bitシフトで終わり"
				//@comment "最後にTT1 OR TT2"

				TT2 = TT1 | TT2
				//@comment "TT1 = upper left morton
				//TT2 = bottom right morton
				//TT5 = shift num"
				TT3 = TT11 ^ TT2
				//@comment "#mask with 11000000
				//@comment ""#mask with 110000""
				//@comment ""#mask with 001100""
				//@comment ""#mask with 000011"""
				
				TT5 = TT3 & 768 ? 10 : TT3 & 192 ? 8 : TT3 & 48 ? 6 : TT3 & 12 ? 4 : TT3 & 3 ? 2 : 0
				agent_Morton = TT2 >> TT5
				//@comment "#mask end"
				TT6 = TT5 >> 1 // TT6 = TT5 / 2
				v[340] = 4546 - TT6
				v[340].deref v[340],1
				v[327] = v[v[4552 - TT6] + agent_Morton]
				//@comment "##############"
				Ptr14 = Temp1 + 25
				v[Ptr14] = 2 + v[327] / v[4522] + v[610] / 19 - s[2001 + v[401]] + (v[842] >= 3 && v[680] <= 0) // (v[842] >= 3 && v[680] <= 0 ? 1 : 0)
					//@comment "DisciplineCheck"
				//opt

				// set real agentid to TT2 
				v[536].deref TT2,1 // TT2 = v[v[536]]

				//GET Colbox XY
				__if DIS_EXPERIMENTAL == -1 {
					//get from AEAB
					get_AEAB_array(TT2,__id(v[337]),AgentExBuffer_SLOT_ColBoxWidth,2)
				}.else bl {
					val_asg(v[337],v[4523]) // v[337] = v[4523] 
					v[337] += v[401] * 2
					v[v[337]].copy v[337], 2
				}

				//v[339] as a ptr
				v[339] = agent_Morton * v[1004] 
				v[339].add v[340],1 // v[339] += v[340]
				

				//experimental
				Col_Ptr2AgentBits.deref TT4,1
				Ptr5 = Const_save_var_TileFlags + v[632]
				@if `v[Ptr5] & FLAG_Maptile_Crowded {
					// shuffling too much size array causes lag so set limitation on the max num
					TT1 = min(v[327],8) // changed 16 -> 8
					v[v[339]].shuffle TT1
					def KILLDISCP = ~AgentBits_Discipline_Col
					TT4 &= KILLDISCP
				}
				
				//v[203] = Ptr
				v[339].copy v[203],1 // v[203] = v[339] //set &array[0]
				

				// set pointer for push
				Ptr19 = Temp1 + 15
				@if `TT4 & AgentBits_Discipline_Col { // the agent has discipline?

						// if so
						Temp10 = agent_TeamID % 3
						@loop v[327] {

							__if DIS_EXPERIMENTAL == -1 {
								// DIS_EXPERIMENTAL - get MetaTeam from AEAB inTT3
								TT3 = v[v[203]]
								get_AEAB_element(TT3,__id(TT3),AgentExBuffer_SLOT_MetaTeam)
							}

							//@if v[700] != TT3 { // EXPERIMENTAL cond

							// cond in case of NOT DIS_EXPERIMENTAL.. you must adjust manually
							@if `Temp10 != v[v[v[203]] + Const_AgentMetaTeam_beginMINUSONE] {
						
								macro_ColCheck_distance()

								macro_ColCheck_push()
								
							}
							increment_var(v[203]) // v[203] += 1 //++
							
						}
						
						
				} .else bl {
						@loop v[327] {
							@if TT2 != v[v[203]] { //not unit itself

								macro_ColCheck_distance()

								macro_ColCheck_push()
										
								
							}
							increment_var(v[203]) // v[203] += 1 //++
						}
						
						
				}
				
				/*
				@if `!(v[Col_Ptr2AgentBits] & AgentBits_Collided_Other_Agent) { // NOT collided
					v[Col_Ptr2AgentBits] &= -385 // ~384
					
				}
				*/
				
				v[Col_Ptr2AgentBits] &= v[Col_Ptr2AgentBits] & AgentBits_Collided_Other_Agent ? v[Col_Ptr2AgentBits] : -385 // is this really faster than above?

				
			}
			
	}


}



__fn macro_ColCheck_distance {

	victim_AgentType = v[v[203]] * 300
	val_add(victim_AgentType,N4701) // victim_AgentType += 4701
	v[victim_AgentType].copy victim_AgentType,102
	victim_RelativeX.sub agent_RelativeX,2

	//get colbox
	__if DIS_EXPERIMENTAL == -1 { // pixel edit bug
		//get from AEAB
		v[322] = v[v[203]]
		get_AEAB_array(v[322],__id(v[322]),AgentExBuffer_SLOT_ColBoxWidth,2)
	}.elif DIS_EXPERIMENTAL == -2 { // use raw hitbox as a collision?
		victim_Width.copy v[322],2
	}.else bl {
		v[322] = Address_Agent_HitCollisionArrayStartMinus2 
		v[322] += v[v[203]] * 2
		v[v[322]].copy v[322],2
	}
	
	v[322].add v[337],2
	//func_devlog("\v[\v[203]]: \v[322] \v[323] \Temp20 \v[321]")

}

__fn macro_ColCheck_push {
	v[324] = abs(victim_RelativeX)
	@if v[322] >= v[324] {
		v[325] = abs(victim_RelativeY)
		@if v[323] >= v[325] {
			// if the agents are in the completely same coordinate
			@if victim_RelativeX == 0 {
				@if victim_RelativeY == 0 {
					// then push it to random direction
					victim_RelativeX = rnd(-2,2) 
					victim_RelativeY = rnd(-2,2)
				}
			}
			def TileCrowdedANDtooMany = 6
			v[__id(victim_RelativeX)..__id(victim_RelativeY)] *= (v[527 + (((v[Col_Ptr2AgentBits] | ((agent_MoveTypeBIts & MoveTypeBits_Horse && agent_InCombatTimer > 0) << 8)) & 256) >> 8)]) - ((v[Ptr5] & TileCrowdedANDtooMany) << 8) // if it's Crowded, push more
			v[Ptr19] .add victim_RelativeX, 2
			
			defv Col_Ptr2AI_routine_bits = __id(Temp33) 
			@if victim_AgentType == 11 { // pushed by static agent
				@if agent_MovementOrder > 0 {
					@if v[v[203]] != agent_TargetAgentID { // NOT target
						@if victim_TeamID == agent_TeamID { // and it's ally
							Col_Ptr2AI_routine_bits = Temp1 + 34
							def Col_AIFLAG_PFandSkip = AI_routine_bits_FLAG_PATHFINDING + AI_routine_bits_FLAG_1secDelay_PF
							v[Col_Ptr2AI_routine_bits] |= agent_LeftWPtoChase > 0 ? Col_AIFLAG_PFandSkip : AI_routine_bits_FLAG_PATHFINDING

						}
					}
				}
			}

			v[Col_Ptr2AgentBits] |= AgentBits_Collided_Other_Agent
			@break
		}
	}
}
>>>>>>> 88b5194136650670640ef002a8086e2b5f7f7357
